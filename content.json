{"pages":[{"title":"about","text":"안녕하세요.종민짱입니다. 연락은 jongminzzang97@gmail.com로 부탁드립니다.몇 시간내에 확인합니다.","link":"/about/index.html"},{"title":"blogmap","text":"블로그의 글이 어떤 카테고리 내에서 작성되었는지 보기 쉽게 정리하였습니다.작성된 글은 클릭을 통해 확인할 수 있습니다. 아직 작성되지 않은 글이 대부분이며, 작성된 글의 내용도 수시로 변경될 수 있습니다.ㅎㅎㅎ what / how (long)공부하면서 막혀서 찾아본 내용, 알고있었지만 정리하고 싶었던 부분을 정리합니다. 개요 question (short)위와 비슷하지만 짧게 정리 되는 글 입니다. 개요 자료구조/알고리즘사실은 코딩테스트를 위한…. 개요 자료구조 / 알고리즘 1 (리스트, 스택, 큐) 자료구조 / 알고리즘 2 (트리, 힙) 심화 자료구조 / 알고리즘 3 (세그먼트 트리) 동적계획법 내가 푼 문제들 -&gt; git project진행한 프로젝트입니다.학교에 과제로 진행했던 작은 규모의 프로젝트가 많습니다.","link":"/blogmap/index.html"},{"title":"algorithm","text":"알고리즘입니다.풀었던 모든 문제 중에 쉬우면서 배울게 많은 것만 적어두었습니다. 문제를 클릭하면 github주소로 ★의 개수는 중요도가 아닌내가 배운 것이 많고 정리해 놓은 내용이 얼마나 많은가임 프로그래머스level1_내적level1_없는 숫자 더하기level2_가장 큰 수★★level2_전화번호 목록★★ 예전에 정리하던 것들","link":"/algorithm/index.html"}],"posts":[{"title":"cplus_typecasting","text":"어제 알고리즘을 풀다가 실수할만한 부분을 발견해서 짧게 정리한다.int형과 double형을 혼용해서 쓰면서 발생한 문제인데, 예시를 통해 설명해보겠다.어렵지 않고 매우 간단한 내용이다. 예시123456int main(void){ int a = 10 - (3 / 2); printf(&quot;%d&quot;, a);} 위 코드가 실행 되었을 때 출력되는 값은 9 이다.3 / 2 = 1.5 에서 0.5를 버리기 대문에 10 - 1 = 9 로 계산이 된다. 123456int main(void){ int a = 10 - (3.0 / 2); printf(&quot;%d&quot;, a);} 그런데 위 코드가 실행 되었을 때 출력되는 값은 8 이다.3.0 / 2 = 1.5로 계산이 되고, 10 - 1.5 = 8.5 로 계산이 된 후 0.5를 버리기 때문이다. 123456int main(void){ int a = 10 - int(3.0 / 2); printf(&quot;%d&quot;, a);} 이 코드는 3.0 / 2 의 결과인 1.5를 int형으로 바꿔버린 것이다.이렇게 바꾸면 다시 첫번째 결과와 동일하게 9를 출력한다. 내가 마주한 상황타입 변환에 관련 된 내용이라 나도 어느정도 아는 내용이였지만,내가 마주한 상황에서 생각하지를 못했다. &lt;math.h&gt;에서 pow()함수를 이용해서 제곱을 계산하였는데, 이 때의 return 값이 double이였다.그래서 위와 비슷한 예시에서 원하는 값을 얻지 못했다. 결론int 형과 double 형의 계산에서는int 형이 더 큰 메모리 공간을 갖는 double형으로 변환되어 계산된다.만약 그 후 대입 연산자가 있다면 대입연산자에 의해서 double 형이 int 형으로 자동형변환 되어 소수점을 버린다. 원하는 값을 얻기위해서는 필요한 순간에 강제 타입변환을 하거나, 모든 변수를 double형으로 통일한후에 원하는 타입으로 변환할 수 있다.","link":"/2021/08/24/cplus-typecasting/"},{"title":"실내&#x2F;실외&#x2F;음식 구분 - 프로젝트","text":"들어가며작년에 수업에서 진행했던 프로젝트를 정리해볼것이다. 코드가 길지 않고 간단하지만 내용으로 보면 쉽지 않고한학기 동안 실습했던 내용을 담고 있어서 배웠던 내용을 정리하는 데에 매우 도움이 되었다. 그때 진행했던 프로젝트를 리뷰하면서 복습해볼 생각이다. 프로젝트의 목표음식, 식당의 내부, 식당의 외부 중 하나에 속하는 이미지가 주어졌을 때,어디에 속하는 이미지인지 판단할 수 있는 모델을 만든다. 모델의 정확도는 높을수록 좋다. 이용할 데이터음식사진 20000장, 식당 내부사진 15000장, 식당 외부사진 10000장을 제공받았다.(수업을 듣는 학생들이 몇백장정도씩 직접 분류하였다.) 이 이미지들을 이용하여 학습하고 모델을 생성한다. 전체 코드많은양의 코드가 아니란 것을 보여주기 위해 전체코드부터 제공한다. 짧게 전체적인 과정을 먼저 설명하자면 다음과 같다. 모델 만들기 (함수) 그래프 그리기 (함수) 이미지 읽어오기 학습 코드 확인 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import numpy as npimport osimport matplotlib.pyplot as pltfrom tensorflow.keras.models import Sequential, load_modelfrom tensorflow.keras.layers import Input, Dense, Conv2D, MaxPooling2D, Flatten, BatchNormalizationfrom keras.utils import np_utils, to_categorical,multi_gpu_modelfrom keras.datasets import mnistfrom keras.preprocessing.image import array_to_img, img_to_array, load_imgfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_splitdef gen_sequential_model(): model = Sequential([ Input(shape=(300,300,3), name = 'input_layer'), BatchNormalization(), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer1'), MaxPooling2D(pool_size=(2,2)), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer2'), MaxPooling2D(pool_size=(2,2)), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer3'), MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer4'), #MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer5'), MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer6'), MaxPooling2D(pool_size=(2,2)), Flatten(), Dense(3, activation='softmax', name='output_layer') ]) model.compile(optimizer='adam', loss='categorical_crossentropy',metrics=['accuracy']) #model = keras.utils.multi_gpu_model(model, gpus=4) model.summary() return modeldef plot_loss_curve(history): import matplotlib.pyplot as plt plt.figure(figsize=(15, 10)) plt.plot(history.history['loss'][1:]) plt.plot(history.history['val_loss'][1:]) #plt.plot(history.history['val_loss'][1:]) plt.title('model loss') plt.ylabel('loss') plt.xlabel('epoch') plt.legend(['train', 'test'], loc='upper right') plt.show() #이거 캡쳐하기 path = r&quot;C:\\Users\\이종민&quot;trainFileList = os.listdir(path)trainFileList = [x for x in trainFileList if 'jpg' in x]train_datagen = ImageDataGenerator()training_set = train_datagen.flow_from_directory(path+&quot;\\images_train&quot;, target_size = (300, 300), batch_size = 32, class_mode = 'categorical')test_datagen = ImageDataGenerator()test_set = test_datagen.flow_from_directory(path+&quot;\\images_test&quot;, target_size = (300, 300), batch_size = 32, class_mode = 'categorical')model = gen_sequential_model()history = model.fit(training_set,steps_per_epoch=30, epochs=50, validation_data=test_set)model.save('이종민-2017114152')plot_loss_curve(history)print(history.history)print(&quot;train loss=&quot;, history.history['loss'][-1])print(&quot;test loss=&quot;, history.history['val_loss'][-1])print(test_set.class_indices)print(training_set.class_indices)","link":"/2021/09/03/image-classification-project/"},{"title":"GCD(Greatest common divisor) 알고리즘","text":"사실 알고리즘이라기도 애매할 정도로 쉬운 내용이다.내용은 쉬운데 꾸준히 나오며, 안배우고 처음에 이 방법을 생각해내긴 쉽지 않다.정리하면서 그냥 외우려고 작성한다. 설명A와 B의 최대공약수를 구해보자. A = ac, B = bc 이며 c는 최대공약수라 가정해보자.A &gt; B 라고 한다면 A와 B의 관계식을 다음과 같이 작성해 볼 수 있다.ac = k * bc + X (이때 k는 상수이며 X는 나머지 이다.) 우변이 c로 나눠지므로 X로 c로 나눠떨어져야 한다.ac = k * bc + X-&gt; ac = k * bc + xc 와 같이 식을 작성할 수 있다. 그러면 여기서 b와 x는 c라는 약수를 공유한다.따라서 bc와 xc의 최대공약수를 구함으로써 ac와 bc의 최대공약수를 구할 수 있다는 것이 아이디어이다. 그런데 bc와 xc의 최대공약수가 ac와 bc의 최대공약수임을 보장할 수 있는가?b와 x가 약수를 갖을 수도 있는것 아닌가?b와 c가 또다른 약수 d를 갖는다고 해보자. 그럼 식은 다음과 같이 바뀔 수 있다.ac = k * b’cd + x’cd만약 이런식으로 작성된다면 우변은 cd로 묶일 수 있다.그렇다면 좌변도 마찬가지로 cd로 나눠질 수 있어야 한다.a’cd = k * b’cd + x’cd따라서 여기서의 최대공약수는 cd이므로 A와 B의 최대공약수는 c라는 가정에 모순된다. 위의 과정을 반복하면서 X가 0일때,즉 나머지가 없을때의 작은수가 최대공약수가 된다. 매우쉬운 내용인데 글로 쓰니까 길기만 길다. 코드123456789101112131415161718def gcd(A, B): if B &gt; A: A, B = B, A if B &lt; 1: return 0 while(True): X = A % B if X == 0: break A = B B = X return B","link":"/2021/10/21/gcd-algorithm/"},{"title":"While문 습관 바꾸기","text":"나는 while문을 작성할 때,while 옆에 조건을 바로 작성하지 않고 조건을 만족할 때 break하도록 주로 작성한다 이게 나쁘다고는 생각하지 않고 스스로 코드를 이해할 때도 편하긴한데,남의 코드를 참고하거나 남들이 내 코드를 볼 때는 불편할 수도 있겠다 싶어서 바꾸려고 한다. 내용기존의 나는 다음과 같이 작성했다. 12345678910while(True): # ... (1) if 조건문: break # ... (2) 바꾸려고 의도하는대로 바꾸면 다음과 같다. 12345while(!조건문): # ... (1) + (2) 기존에 작성하던 방식을 아래와 같이 바꾼는 것은 어렵지 않다.while 옆의 조건에 원래 작성하려던 조건의 부정문을 작성해주면 된다. 다만 다음과 같이 작성했을 때 생길 수 있는 문제가 있는데. 위의 방식에서는 (1)번 코드는 조건문 검사없이 무조건 한번은 실행되는 반면,아래의 방싟에서는 (1)번 코드가 실행되기 전에 조건문 검사를 실행한다. 그러면 do-while뭐 이런걸 실행하면 되는데 더 보기 어려울 것 같다.그냥 while 전에 (1)코드를 한 번 실행할 수 있도록 해주거나, 조건을 조금 바꿔주는 편이 좋을 것 같다. 예시12345678910x = 0while(True): x += 1 if x == 3: break print(&quot;hi&quot;) 위의 코드를 아래와 같이 바꾸면 문제가 생긴다. 123456x = 0while(x!=3): x += 1 print(&quot;hi&quot;) 문제가 생기지 않게 하려면 아래 방법처럼 바꿀 수 있다.(당연히 다른 방법도 많이 있다.) (1)번 코드를 미리 한번 실행하는 것으로 처리 1234567x = 0x += 1while(x!=3): x += 1 print(&quot;hi&quot;) 조건을 조금 바꿔줌으로써 처리 123456x = 0while(x!=2): x += 1 print(&quot;hi&quot;) 정리쉬운 내용이지만 나를 위해서 정리해봤다 ㅎㅎ","link":"/2021/10/22/fix-whileloop/"},{"title":"Iterable_object","text":"파이썬은 반복문을 iterable한 객체를 통해 진행한다.어떻게 작동하는지 공부하고 작성한 글이다. iterable 객체(ierable과 iterator)쉽게 이해하고 싶은 사람은 iterable한 타입이란 iterator라는 어떤 객체를 통해 다음 값에 접근 할 수 있도록 설계되어 진 것이라 생각하면 된다. 대표적으로 list, tuple, dictionary, set, range, string이 있고 그리고 iterable한 객체들은 for문에서 사용될 수 있다는 것까지 알아두면 좋다. iterator = 반복자, iterable = 반복가능한 타입이라고 생각을하면 쉽다. 예시를 작성해보겠다. list 와 list에 대한 iterator는 다음과 같이 생성할 수 있다. a = [1, 2, 3, 4, 5] a_iterator = iter(a) next(a_iterator) a 는 list고 이는 iterable한 타입이다. 그리고 다음줄에 선언한 a_iterator가 리스트 a에 대한 iterator이다. 리스트 a에 대한 iterator가 생성가능하므로 a는 iterable하다고도 할 수 있다. a_iterator는 next라는 함수를 통해 리스트의 다음 값에 접근 할 수 있다. 이렇듯 iter()을 이용하여 iterator 객체를 생성가능한 것들을 iterable 하며 iterable 한 객체는 내부적으로 매직메소드 __iter__를 갖고 있다. 디자인 패턴에서 iterator 패턴이 있다. 정의는 '컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공해 주는 패턴' 이다. 실제로 대부분은 for문에서 iterable한 객체가 쓰일 수 있다는 것은 알지만 이게 어떻게 가능한 것인지는 모른다. 그것 자체로 컬렉션의 구현 방법을 노출시키지 않았다고 할 수 있다. 또한 위의 예제에서도 iterator 객체를 통해 원하는 값에 접근은 가능한 반면 실제로 list라는 컬렉션이 어떻게 구현되어 있는지에 대한 정보를 알 필요가 없다. 참고) https://suwoni-codelab.com/python%20%EA%B8%B0%EB%B3%B8/2018/03/06/Python-Basic-Iterable-iterator/ for in문에서 iterable 객체파이썬에서는 주로 for in 문을 사용하여 반복문을 나타낸다. for in 문에서 반복의 조건으로 iterable 객체들이 사용될 수 있다. iterable 객체란 반복이 가능한 객체로 list, tuple, dictionary, set, range, string, byte들이 이에 해당한다. 사용방법은 다음과 같다. for item in iterable: 반복할 부분.... ex) for i in range(20): print(i) 다른 언어에서는 주로 몇번째 반복인지의 count를 이용해서 list[count]처럼 접근해야 했던 것과는 달리, 바로 그 시행에서의 item을 이용할 수 있다. iterable한 객체를 list로list() 함수를 이용하여 iterable한 타입의 객체를 list로 바꿀 수 있다. a = list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] b = list(combinations([1, 2, 3, 4], 2)) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]","link":"/2021/12/06/Iterable-object/"},{"title":"compiled vs interpreted","text":"매번 강조되는 내용이고 적당히 알고있었다.공부하다가 궁금했고 글로 정리했다. Compiled Languages vs Interpreted Languages주로 컴파일 언어, 인터프리터 언어라고 부른다. 근데 compile에 대응되는 단어는 interpret, interpreter 에 대응되는 단어는 compiler이다. 영어로는 Compiled Languages and Interpreted Languages라 사용 되는거 보니 컴파일 언어, 인터프리터 언어로의 번역은 조금 잘 못된 것 같긴하다. 컴파일러, 인터프리터는 일단 소프트웨어(프로그램)이라는 것을 확실히 하고 시작하자. (그러면서 위의 단어가 잘못되었음을 알았다.) 컴파일러는 내가 프로그래밍 언어로 작성한 문서를 한번에 기계어로 바꿔 실행 파일을 생성해주는 소프트웨어이다. 그리고 인터프리터는 내가 프로그래밍 언어로 작성한 문서를 번역하며 실행까지 해주는 소프트웨어이다. 즉 컴파일러가 생성한 실행파일은 컴퓨터가 직접 실행이 가능하며, 인터프리터는 실행파일을 만들지 않고 코드를 직접 인터프리터가 실행한다. 밑의 내용을 보면 조금 확실해진다. 여러 것들을 찾아보고 공부해본 결과 Compiled Languages와 Interpreted Languages를 구분하는 기준은 &quot;코드 전체를 한번에 기계어로 번역 하느냐&quot;이고, 이 이유 때문에 여러 차이점이 존제한다. Compiled Languages는 코드 전체를 한번에 기계어로 번역한다. 기계어로 번역한 그것이 실행 파일이 되는 것이다. 물론 코드 전체를 번역해야 하는데 시간이 좀 소요되지만, 실행 속도는 컴퓨터가 기계어를 직접읽기에 매우 빠르다. 또 한번에 전체 코드를 번역하다보니, 최적화의 부분에서도 장점을 갖는다. 그런데 코드를 수정하는데 있어서는 번거롭다. 전체를 실행하면서 오류를 찾아 내야 하고, 오류를 찾아 냈다고 하더라도 다시 전체 코드를 컴파일 해야한다. 또한 이 부분은 내 생각이긴 한데, C언어에서 타입에 대한 검사나 메모리 할당을 미리 하는 이유는 컴파일 하기 전에는 어떤 변수가 어떤 값을 갖을지 어차피 알고 있다. 또한 메모리도 어느 정도 필요한지를 미리 알 수가 있다. 그래서 그런 것에 대한 검사를 엄격하게 하면서, 컴파일시 최적화의 이점을 더욱 살리려고 한 것 같다. 반면 Interpreted Languages는 코드 전체를 한번에 기계어로 번역하지 않는다. 그렇기 때문에 전체 코드를 기계어로 번역한 실행 파일이 생성 되지 않는다. 실행시키는 부분의 번역만을 진행한다. 실행 시간에 번역시간도 포함되게 됨으로 실행 시간이 비교적 오래걸릴 수 밖에 없다. 또한 코드의 최적화도 실행시키는 부분내에서만 일어날 수 있다. 현재까지 진행한 부분을 실행해보면서 오류를 수정하고 수정하여 다시 그 부분을 실행해보면 되기 때문에 코드 수정에서의 유리함이 있다. 위의 내 생각에 추가해보자면, 인터프리터 언어는 앞으로 어떤 코드가 작성될 지 알 수 없다. 그렇기 때문에 타입을 선언하여 미리 크기를 정해두기 힘들다. 순간적으로 입력되는 값에 따라서 메모리의 크기를 알맞게 할당할 수도 있고, 크기가 바뀌면 주소를 바꿔야 할 수도 있다. 그렇기에 타입 검사 포기하고 조금 더 융통성 있는 코드를 가능하도록 했을 것이다. Is Java Complie Language?Java가 어떻게 작동하는지는 조금 더 길게 다른글에 정리해 두었으니 읽어보면 좋을 듯하다. 일단 자바는 javac 컴파일러를 이용하여 전체 코드를 한번에 바이트 코드로 바꾸기 때문에 Compiled Language가 맞다. 그 다음에 JVM에서 .class 파일을 기계어로 바꾸며 실행할 때 interpreter를 이용한다. 따라서 interpreter Language도 맞다. 그래서 결국 두 방식을 같이 사용한다고 하는 것이 맞는 것 같다. 뭐 여기서 interpreter를 JIT(Just in time)compiler로 설명하는 내용도 많은데 따로 정리할 시간이 있으면 따로 정리해보겠다.","link":"/2021/12/06/compiled-vs-interpreted/"},{"title":"자바에 대해서","text":"처음 프로그래밍을 배울 때 자바로 시작하는 경우가 많다.많은 과정을 따라하지만 제대로 알진 못한다. 물론 처음에 자바가 무엇인지부터 시작한다면 이해 할 수 없을 것이다.그러나 자바를 계속 사용하기 위해서는 언어외에도 계속 마주하는 용어들이나 작동하는 방식들에대한 정리가 필요하다고 느꼈다. 플렛폼으로써의 자바자바(Java)는 자바로 기술된 프로그램 개발 및 실행을 할 수 있는 소프트웨어 모임의 총칭이다. 자바 프로그램은 운영체제나 하드웨어에 의존하지 않는 바이트 코드(중간 언어)인 추상적인 코드 로 구현된다. 따라서, 자바 프로그램을 실행하기 위해서는 자바 가상 머신(JVM)과 개발에 필요한 표준 라이브러리 세트와 컴파일러의 환경만 맞추면 자바 프로그램은 모든 환경에서 동일하게 동작한다. 이러한 실행환경과 개발환경을 제공하는 것이 자바 플랫폼이다. 자바 플랫폼은 자바 언어(Java Language), 자바 애플리케이션(Java Application), 자바 애플릿(Java Applet), JRE(Java Runtime Environment), 자바 가상 머신(Java Virtual Machine), 모바일용 자바(Java ME), 자바 웹 스타트(Java Web Start) 등과 함께 단순히 「자바」(Java)라 불리는 경우가 많다. 출처: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%94%8C%EB%9E%AB%ED%8F%BC) 내가 정리하고자 했던 내용을 직접 작성하는 것 보다 훨씬 뛰어나게 잘 요약된 글이 있어서 그대로 가져왔다. 자바의 실행방식 : 자바 플랫폼Java의 실행방식은 조금 특이하다. 컴파일 언어와 인터프리터 언어의 방식을 모두 사용한다고 할 수 있다. 먼저 개발자가 작성한 코드는 .java 파일에 저장이 된다. 작성된 코드는 실행을 위해 컴파일이 되어야 하고 그 결과가 .class 파일이다. 이 파일은 JVM(Java Virtual Machine)이라는 가상환경에서 실행된다. 이 때 실행되는 방식이 인터프리터 방식이다. JVM은 .class파일의 바이트 코드를 한줄 씩 해석하며 실행한다. WORA(Write Once, Read Anywhere) 플랫폼에 종속되지 않고 사용하기 위해서 이 방식을 채택하였다는 것이 중요하다. 컴파일이란 개발자가 작성한 코드를 실행 가능한 파일로 바꾸는 과정이라 생각하면 된다. 그런데 CPU마다 명령어의 체계가 다르고 운영체제에 따라 API도 다르다. 따라서 일반적인 컴파일 언어에서 컴파일 된 파일은 다른 환경에서 작동하지 않을 가능성이 높다. Java의 경우 그것을 JVM을 통해 해결한다. 컴파일 된 바이트 코드는 JVM 위에서 실행되기에 환경에 신경쓰지 않고 실행될 수 있다. 물론 컴파일 된 자파 파일 .class 파일을 해석할 수 있는 자바 플렛폼을 설치되어있어야만 하고, 특정 운영체제만 갖고있는 기능은 이용하지 못할 수도 있다는 단점이 있다. JDK, JRE다운로드를 하려다 보면 마주하게 되는 단어들이다. JRE은 Java Runtime Environment의 약자이다. JRE는 개발을 하지 않지만 자바 파일을 실행해야 하는 사람들이 다운 받으면 되는 것 이다. 실행할 수 있도록 하는 JVM을 포함하여, 라이브러리 등이 포함된다. .class파일을 JVM에서 실행하기 위한 JIT(just in time) compiler, 메모리의 관리를 도와주는 garbage collector등도 포함되어 있다. JDK는 Java Development Kit의 약자이며, 다시 말해 자바 개발을 하기 위해 필요한 묶음이다. 코드를 작성하고 실행해볼 때는 라이브러리들도 필요하고, 컴파일의 과정도 거쳐야하며, 컴파일의 결과를 JVM위에서 실행도 해봐야 한다. 이런 모든 것들을 묶어서 배포하는 것이 JDK이다. 따라서 JDK를 다운로드 받으면 JRE도 포함되어 있다. 가장 중요한 차이는 컴파일을 하기 위한 javac의 포함 여부이며 다른 javadoc(Java documentation generator)이나 jdb(Java Debugger)같은 툴또한 JDK에만 제공된다. JVM 추가https://stackoverflow.com/questions/7674839/is-the-jvm-a-compiler-or-an-interpreter 매우 좋은 글이 있어서 가져왔다. 직접 읽는 것이 더욱 좋다. 질문 : JRE는 컴파일러냐 인터프리터냐 둘다 아니라면 무엇이냐? 답 : JVM is Java Virtual Machine -- Runs/ Interprets/ translates Bytecode into Native Machine Code JVM is a virtual platform that resides on your RAM Its component, Class loader loads the .class file into the RAM The Byte code Verifier component in JVM checks if there are any access restriction violations in your code. (This is one of the principle reasons why java is secure) Next, the Execution Engine component converts the Bytecode into executable machine code JVM은 램위에 존재하는 가상 플랫폼이다. 그것의 구성요소인 Class loader는 .class파일을 램 위에 올린다. 다른 구성요소인 Byte code Verifier는 코드의 접근 제한이나 위험을 검사한다. (이것이 자바가 안전한 이유 중 하나이다.) 그리고 실행 엔진이 바이트 코드를 실행가능한 기계코드로 바꾼다. https://www.guru99.com/java-virtual-machine-jvm.html https://www.youtube.com/watch?v=G1ubVOl9IBw&amp;t=2s 이것 또한 참고할만하다. 버전java version 을 보면 8, 9, 10, 11 이렇게 볼 수 도 있고 1.7.2, 1.8.0과 같이 적혀있는 것도 볼 수 있다. java 9 이전의 버전에서는 버전을 작성하는 방식이 달랐기 때문에, 1.8.0과 같이 작성되었다. 9 이후의 버전에서는 java 9, java 11과 같이 작성한다. 이전 버전에서 컴파일 된 파일은 이후 버전의 jre에서 실행이 가능하다. 그러나 반대는 불가능하다. 또한 이후 버전의 java에서 이전 버전으로 컴파일을 하는 것도 불가능하다. SE vs EEjdk를 다운로드 받을 때 선택하게 된다. SE는 Standard Edition, EE는 Enterprise Edition의 약자이다. 쉽게 말해 일반적으로 사용하기 위해서는 SE, 조금 더 많은 기능을 지원해주는 것이 EE이다. 결합력을 낮추기 위한 DI, DB Transaction 처리, 로그 처리 등이 주요한 기능이였다. EE는 유료인데다가 spring framework가 그 기능들을 잘 지원해 주기에 요즘은 java se에 spring framework등을 얹어서 사용하는 경우도 많다. 참고https://www.oracle.com/java/technologies/javase/jdk8-naming.htmlhttps://dzone.com/articles/a-guide-to-java-versions-and-features","link":"/2021/12/06/abuot-java/"},{"title":"데이터베이스 인덱스","text":"학교수업에서 배웠던 내용 중내가 흥미로웠던 부분을 짧게 정리했다. 데이터베이스 모델링현실 세계의 개체들은 수많은 특성을 갖는다. 예를 들어 한 사람은 이름, 키, 성별, 직업, 수입, 사는 지역, 주민 번호 등 여러 가지 속성들을 가지고 있다. 데이터베이스가 이 모든 정보를 갖고 있을 수는 없다는 것뿐만 아니라 다 저장할 필요도 없다는 사실을 모두 알고 있다. 필요한 정보만 데이터베이스에 저장하면 되고, 그것을 어떻게 저장하고 있을지가 모델링이라 할 수 있다. 따라서 데이터베이스를 모델링은 쉽게 시스템에 필요한 개체는 무엇인지, 개체들이 어느 속성을 가져야 하는지를 정하는 과정이다. 이 과정애서 굉장히 많은 추상화가 일어났다고 할 수 있다. (학생정보시스템에서 필요한 정보는 사람에 대한 모든 정보가 아니다. 단순히 학번, 이름, 학과 등 몇가지 요소들 만으로 표현될 수 있다.) 데이터베이스 인덱스데이터베이스가 학생에 대한 정보를 가지고 있다고해보자 그리고 간단하게 학생은 이름, 학번, 학과만을 갖는다고 하자. 데이터베이스에서 sql을 이용하여 어떤 학생을 찾을 때 얼마나 시간이 소요될까? 튜플들 간에 순서는 없다고 배우니 아마 서치 타임은 O(n)일 것이다. 그런데 저장을 할 때 순서대로 저장을 하도록 할 수 있다. 그리고 이를 이용하여 찾을 때의 서치타임을 줄일 수 있다. 위 테이블에서 주키인 학번 순으로 정렬되어 있다고 하면 내가 1234가 학번인 학생을 찾을 때의 서치 타임은 O(log n)이 된다. (binary search를 이용) 이것은 매우 큰 차이이다. (후에 서술) 그런데 학번 순으로 정렬이 되어있으면 이름으로 검색할 때는 서치 타임이 O(n)아닌가? 하나의 기준으로 정렬이 되어 있으면, 그 기준이 아닌 모든 것에 대해서는 다 O(n)으로 서치하게 된다. 그래서 존재하는 것이 인덱스이다. 위 예시에서 이름과 학번만을 묶어서 또 다른 구조체을 만들고 이름 순으로 정렬해 놓는 것이다. 그렇게 하면 이름으로 검색할 때 그 구조체에서 학번을 O(log n)의 서치타임으로 찾을 수 있다. 그리고 학번을 이용해서 원래의 테이블에서 검색할 때도 O(log n)만큼이 소요됨으로 O(log n)의 상수 배 시간만큼 걸린다. 데이터가 100만개라고 해보자. 인덱스를 이용하지 않고 이름으로 어떤 데이터를 찾을 때는 평균 50만번의 비교연산이 필요하다. 그러나 인덱스를 이용하면 100만 = (2^10)^2 = 2^20 이므로 20번의 연산 2번, 즉 40번의 연산 만으로 찾을 수 있다. 데이터가 많을 수록 인덱스의 사용이 더 중요해지는 이유이다.","link":"/2021/12/06/database/"},{"title":"파이썬을 파이썬답게","text":"시작부스트캠프 코딩테스트를 앞두고, 코딩테스트 공부를 했다. 내용자체가 어려울 것 같지는 않고, 구현이 까다로울 것 같아서 파이썬에 조금 더 익숙해지고자 했다. [파이썬을 파이썬답게](https://programmers.co.kr/learn/courses/4008) 라는 좋은 온라인코스가 있어서 빠르게 진행해봤다. 파이썬에서 이용할 수 있는 팁들을 많이 얻을 수 있다. 내용어렵진 않고 몰라서 못했던 내용임으로 단편적인 내용들을 쩗게나열하는 형식으로 작성하겠다. 1. int()함수는 base가 설정가능하다. print(int('10', base = 5)) = 5 print(int('f', base = 16)) 2. 알파벳은 lower(), upper()함수로 대문자 소문자 변환이 가능하다. 3. map()함수의 사용법 map(function, iterable)과 같이 사용하며, iterable한 객체를 돌면서 funtion을 실행한다. return type은 map object 이다. 리스트로 사용하고 싶다면 list()를 통해서 리스트로 변경해줄 수 있다. 4. zip()함수의 사용법 zip(iterable A, iterable B)와 같이 사용하며, iterable한 객체를 돌면서 둘을 합친 반복자를 반환한다. return type은 zip object 이다. zip object또한 iterable한 객체이며, list()를 통해서 리스트로 변경해줄 수도 있다. zip 함수에 서로 길이가 다른 리스트가 인자로 들어오는 경우에는 길이가 짧은 쪽 까지만 이터레이션이 이루어진다. 5. *로 unpacking이 가능하다. 6. for-else문이 가능하다. for _ in X: if 조건: 실행1 break else: 실행2 break가 일어나지 않으면 else가 실행된다! 7. iterable object to string object s = ''.join(iterable) 8. flatten 2D list to 1D list 1) answer = sum(my_list, []) -&gt; list + list = list 2) list(itertools.chain(*my_list)) -&gt; unpacking을 이해해야한다! -&gt; itertools.chain(iterable1, iterable2, iterable3) 간단히 말하면 리스트(lists/tuples/iterables) 를 연결하는 것이다. 3) [element for array in my_list for element in array] -&gt; list comprehension 4) np.array(my_list).flatten().tolist() -&gt; using numpy 9. iterable 객체의 곱집합 list(itertools.product(iterable1, iterable2, iterable3)) 10. 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있다. l = [x*x for x in range(10) if x%2 == 0] -&gt;[0, 4, 16, 36, 64] 11. 이분탐색이 구현되어 있다. bisect를 import 하고 bisect()와 bisect_left()를 사용할 수 있다. bisect(list,val)는 list에서 val이 추가될 때의 index를 return 한다. bisect_left는 index하나 감소 (정렬된 상태에서 사용하자) 12. from collection import deque deque은 매우 장점이 많은 자료구조이다. queue나 stack의 자료구조의 이해는 필요하지만 두자료구조를 구현할 때 deque을 써서 나쁠게 없다. (특히나 코테에선 더욱 그러하다.) 13. gcd 또한 구현되어있다. gcd = math.gcd(A, B) 정리파이썬은 확실히 사용하기 편하고 보기 편한게 장점인 것 같다. 새롭게 알게되는 내용이 있다면 추가해야겠다. 혹시 누가보실진 모르겠지만, 내용을 매우 얕게 정리해두었으니 몰랐던 내용이 있으시다면 조금 더 찾아보시는게 좋을것 같아요!","link":"/2021/12/17/study-python-skills/"}],"tags":[{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"프로젝트","slug":"프로젝트","link":"/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"머신러닝","slug":"머신러닝","link":"/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"이미지 분류","slug":"이미지-분류","link":"/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%84%EB%A5%98/"},{"name":"gcd","slug":"gcd","link":"/tags/gcd/"},{"name":"짧","slug":"짧","link":"/tags/%EC%A7%A7/"},{"name":"자료형","slug":"자료형","link":"/tags/%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"타입변환","slug":"타입변환","link":"/tags/%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98/"},{"name":"while문","slug":"while문","link":"/tags/while%EB%AC%B8/"},{"name":"iterable","slug":"iterable","link":"/tags/iterable/"},{"name":"iterator","slug":"iterator","link":"/tags/iterator/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"compiled laguage","slug":"compiled-laguage","link":"/tags/compiled-laguage/"},{"name":"interpreted laguage","slug":"interpreted-laguage","link":"/tags/interpreted-laguage/"},{"name":"컴퓨터언어","slug":"컴퓨터언어","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%96%B8%EC%96%B4/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"파이썬","slug":"파이썬","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}],"categories":[{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"프로젝트","slug":"프로젝트","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"짧","slug":"짧","link":"/categories/%EC%A7%A7/"},{"name":"study","slug":"study","link":"/categories/study/"},{"name":"파이썬","slug":"파이썬","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}]}