{"pages":[{"title":"about","text":"안녕하세요.종민짱입니다. 연락은 jongminzzang97@gmail.com로 부탁드립니다.몇 시간내에 확인합니다.","link":"/about/index.html"},{"title":"blogmap","text":"블로그의 글이 어떤 카테고리 내에서 작성되었는지 보기 쉽게 정리하였습니다.작성된 글은 클릭을 통해 확인할 수 있습니다. 아직 작성되지 않은 글이 대부분이며, 작성된 글의 내용도 수시로 변경될 수 있습니다. what / how (long)공부하면서 막혀서 찾아본 내용, 알고있었지만 정리하고 싶었던 부분을 정리합니다. 개요 question (short)위와 비슷하지만 짧게 정리 되는 글 입니다. 개요 자료구조/알고리즘사실은 코딩테스트를 위한…. 개요 자료구조 / 알고리즘 1 (리스트, 스택, 큐) 자료구조 / 알고리즘 2 (트리, 힙) 심화 자료구조 / 알고리즘 3 (세그먼트 트리) 동적계획법 내가 푼 문제들 -&gt; git project진행한 프로젝트입니다.학교에 과제로 진행했던 작은 규모의 프로젝트가 많습니다.","link":"/blogmap/index.html"}],"posts":[{"title":"Hi, blog start!","text":"시작드디어 블로그를 만들었다. 생각보다 블로그를 만드는 것이 쉽지 않았다. using hexo네이버 블로그는 컴퓨터 분야와 잘 맞지 않는다고 생각했고, 티스토리는 최근에 속도가 좀 느려지고 이용률이 줄고 있다고 느꼈다. 많은 사람들이 github 주소의 블로그를 가지고 있는 것을 보며 나도 github pages를 이용해서 블로그를 만들기로 마음을 먹었다. github pages를 이용하여 블로그를 만드는 방법은 주로 아래 3가지 방법 중 하나이다. 직접 코딩 jekyll을 이용 hexo를 이용 일단 jekyll이나 hexo는 조금의 차이는 있지만 다른 사람이 만들어 놓은 테마를 이용하는 것이다.따라서 매우 간단하게 만들 수 있으며, post를 markdown으로 작성할 수 있다.markdown으로 작성하면서 또 하나의 좋은점은 내가 작성한 글들을 md파일로 저장하고 있으면블로그를 옮기더라도 바로 이전 글을 업로드 할 수 있다는 점이다. 직접 코딩을 한다면 내가 원하는 데로 만들 수 있다는 것이 가장 큰 장점이다.그러나 단순히 공부한 것을 정리하기 위한 블로그를 직접 만드는 것은 너무 귀찮다. 처음에는 jekyll을 이용하고자 하였다. 그리고 어렵지 않게 만들었다.근데 자꾸 사소한 오류가 발생하고 조금씩 마음에 들지 않는 부분이 있어서 그냥 처음부터 만들까 시도도 했지만,너무 해야될 일이 많아지는 것 같아 결국 hexo를 이용하게 되었다. 결과적으로 jekyll, hexo 모두를 이용해보면서 사소한 차이점을 찾았다.jekyll을 이용할 때에는 markdown으로 작성한 파일을 github에 push하기만 하면 된다.실제로 gitclone으로 jekyll의 설치없이 테마만 다운받고 markdown만 작성해도 이용할 수 있다. 반면 hexo는 generate, deploy 명령어를 이용한다.즉 github에 내가 작업한 폴더가 그대로 올라가는 것이 아니라 작업 폴더를 이용해 웹을 생성하고 그 웹을 github에 올린다.generate과정에서 md파일을 html로 변환하고 config.yml의 정보들이 이용된다.즉 markdown을 이용하여 작성한 post와 config.yml등은 github에 같이 업로드 되지 않는다. 블로그를 만들면서 참고한 것기본적으로는 유튜브 영상을 보면서 따라했고, 밑의 블로그의 글도 정말 도움도 많이 받았다. 카인드페밀리 - 오늘 부터 나도 github.io 블로그 운영자다!! | github pages , goormide, hexo 멋진 깃허브 블로그 시작하기","link":"/2021/08/09/hi/"},{"title":"자료구조 &#x2F; 알고리즘 개요","text":"힉교에서 2학년 1학기때 자료구조를 배우고 2학기에 알고리즘을 배웠다.이번에 삼성알고리즘 특감에 참여하면서 여태까지 배운 내용을 정리해보고자 한다. 자료구조 수업에서는 c언어로 자료구조들을 구현해보는 정도였다.큐, 스택, 연결리스트, 트리 등을 구조체로 구현하면서 포인터 사용법도 익히고 코딩하는 법도 배웠다.그리고 강의가 끝나고는 결국 연결리스트가 전부 아닌가? 라는 생각을 가졌다. 알고리즘 수업에서는 문제를 코드로 구현하는 것 보다는,하나의 어려운 문제를 어떻게 해결해 나갈 수 있을지에 대해서 배웠다. 사실 두 수업을 들었다고는 하나 문제를 풀어본 적은 거의 없었고,4학년이 돼서 취업을 위해 코딩테스트를 봐야 하는 상황에 놓이고 다시 공부를 했다.공부를 해보니 내가 생각했던 것 보다 공부해야 할 내용도 많았고,내용을 알고있더라도 실제로 푸는 것은 쉽지 않았다. 그러다 이번에 삼성SDS에서 진행한 2021 하계알고리즘 특강에 참여하게 되었다.이 수업을 들으면서 전체적으로 자료구조와 알고리즘에 대한 생각이 많이 정리 되었다.(알고리즘 특강에 대해서는 따로 글을 작성할 수 있으면 작성하겠다.)아무튼 스스로 한번 정리해보면 좋을 것 같아서 정해놓은 목차에 따라 글을 작성해보려고 한다.","link":"/2021/08/11/ds-al-outline/"},{"title":"자료구조 &#x2F; 알고리즘 1 (리스트 - 배열, 연결리스트)","text":"들어가기기본적인 자료구조인 리스트 스택 큐에 대해서 다뤄본다.너무 쉽고 기초적인 내용이지만 그 만큼 많은 분야에서 사용되며, 이 내용을 알아야 다른 내용 또한 이해할 수 있다. 리스트를 구현하는 두 가지 방법인 배열과 연결리스트는 다른 자료구조를 구현 할 때 계속 사용된다.따라서 확실히 공부해둔다면 다른 자료구조를 쉽게 배울 수 있다고 생각한다. 본격적인 내용시작전에 말을 조금 더하자면,자료구조마다 사용하는 연산(함수)가 다르고 연산의 속도또한 다르다. 그렇기 때문에 자료구조마다 사용되는 곳이 다르다. 특정한 상황에 알맞은 자료구조를 사용하는 지를 선택하는 것은,코드를 작성할 때도 편리함을 제공하지만 결과적으로 프로그램의 속도에까지 영향을 줄 수 있다.(그렇기에 알고리즘 문제를 풀 때 자료구조를 잘 선택해야 한다.)따라서 각각의 자료구조가 어디서 이용될 수 있는지 생각해보는 것도 중요하다. 내가 학교에서 자료구조 강의를 들었을 때는 삽입, 삭제, 검색, 정렬 등의 함수를 구형하는 것이 과제였는데,한번 구현해 보는 것도 도움이 될 수 있겠다고 생각한다. 리스트리스트는 선형구조로 원소들이 제시되는 상황에서 많이 사용된다.그리고 실제로 다루게될 대부분에 데이터들은 리스트의 형태이다. 리스트로 주어지는 데이터를 컴퓨터에서 저장할 때는 주로 두 가지 방법을 이용한는데,하나는 배열 그리고 다른 하나는 연결리스트다. 다른 자료구조들을 이 두가지 자료구조를 이용하여 구현되기 때문에 이 둘을 정확히 아는 것이 중요하다. 배열(array)배열을 선언하면 실제 컴퓨터 상에 연속한 공간에 데이터들이 배치되었다 생각할 수 있다.이 사실이 매우 중요한데, 이는 내가 접근하고자 하는 원소의 주소를 바로 계산가능하게 해주기 때문이다. 어떤 타입의 배열일수도, 어떤 클레스의 배열일수도 있지만 하나의 원소의 크기는 일정하다.그렇기에 배열의 시작주소에, 원소하나의 크기 그리고 접근하고자 하는 원소의 순서를 곱해서 더하면 주소값을 바로 구할 수 있다.즉 (배열의 시작주소) + sizeof(t1)*x 를 통해 값에 바로 접근이 가능하다.이는 index로 원소에 접근할 때 O(1)만에 가능함을 보여준다. 반면 배열 중간에 어떤 원소를 삽입할 때는 조금 번거로운데,삽입하려는 위치보다 뒤에 있는 원소들을 모두 한칸씩 뒤로 이동시키는 과정이 선행되어야 한다.마찬가지로 원소를 삭제할 때도 삭제한 후 뒤에 있는 원소들을 한칸씩 앞으로 이동시켜야 한다. 연결리스트(linked list)연결리스트의 아이디어는 구조체가 값과 다음 원소의 위치 정보를 저장하고 있는 것이다.(많은 사람들이 손을 잡고 일렬로 서있는 것을 생각해 볼 수 있다.)노드라는 구조체를 주로 이용하는데, 노드는 자신의 값(value)와 다음 노드의 주소값을 원소로 갖는다. 어떤 원소에 접근하는 것 부터 배열과 차이를 보인다.만약 내가 index로 연결리스트의 어떤 원소에 접근하려면,첫 번째 노드에 접근하여 두 번째 노드의 주소를 찾고, 두 번재 노드에 접근하여 세 번째 노드의 주소를 찾고와같은 과정을 loop을 통해 반복해야 한다. 리스트 가운데에 원소를 삽입하거나, 중간에 위치한 원소를 삭제할 때 배열보다 연결리스트가 유리하다.그 원소의 위치를 찾을 때 까지는 위에서 언급한 방법으로 찾아야 하지만, 노드를 삭제할 때는 삭제하려는 노드의 이전 노드의 주소 값을 삭제하려는 노드의 다음 원소의 주소값으로 바꿔주면 된다.원소를 삽입할 때는 이전 원소가 갖고 있던 다음 원소의 주소값을 새 노드에게 알려주고,이전 노드에는 새 노드의 주소값을 저장하도록 해준다.말로 하면 어려워 보이지만 그림을 보면 이해하기 어렵지 않다. linked list의 종류가 몇가지 있다.노드가 이전 노드의 주소를 저장하도록 구현하면 이용할 때 조금 유리한 부분이 있는데,이렇게 구현된 linked list는 이중연결리스트라고 한다.그리고 끝나는 노드가 시작 노드의 주소값을 저장하고 있으면,원형연결리스트라고 한다.","link":"/2021/08/15/ds-al-1/"},{"title":"자료구조 &#x2F; 알고리즘 2 (스택, 큐, 덱 )","text":"이전 글에서 언급했다 싶이 스택, 큐, 덱은 모두 선형 구조인 리스트의 일부이다.다만 세 자료구조는 지원하는 연산이 다르다.스택과 큐는 서로 비슷하지만 반대된다고 생각할 수 있으며, 덱은 둘을 합쳐 놓았다고 볼 수 있다.어려운 내용은 아니니 쉽게 이해할 수 있을 것이다. 1. 스택 (stack)1.1 개념게임을 조금 해본 사람들은 스택을 쌓는다는 표현을 들어봤을 수 있다.스택을 배우고 나면 이 표현이 어느정도 알맞는 표현이였다고 생각하게 될 수도 있다. 스택은 들어오는 곳과 나가는 곳이 동일한 선형 구조이다.즉 뒤에 들어온 원소들이 나가줘야만 앞에 있는 원소들이 스택에서 나갈 수 있다.늦게 들어온 것이 먼저 나간다는 의미로 영어에서는 LIFO(LAST IN FIRST OUT) 라는 말을 사용한다.(스택을 설명하기 위해 자주 드는 예시는 프링글즈 통이다.) 스택은 아래서 부터 위로 쌓는 이미지로 생각해도 좋고,앞에서 부터 뒤로 쌓는 이미지로 생각해도 좋다.다만 중요한 것은 위에서 부터 혹은 뒤에서 부터, 즉 쌓인 원소부터 제거된다는 것이다. 스택이 활용되는 가장 대표적인 부분은함수들이 함수들을 실행하고, 프로그램이 프로그램을 실행할때스택에 쌓아가면서 실행하고 종료될 때는 위에 부터 종료되게 함으로 써내부의 함수 또는 프로그램이 외부의 함수 또는 프로그램 보다 먼저 종료되게 해준다. 1.2 지원하는 연산스택이 지원하는 연산은 크게 3가지 이다. push : 스택의 가장 뒤에 값 추가 // 스택의 가장 위에 값 추가 pop : 스택의 가장 마지막 값 제거 // 스택의 가장 위의 값 제거 top : 스택의 가장 마지막 값 반환 top은 사실 스택의 가장 위에 있는 원소를 말하는 것이지만, 연산의 이름으로 사용하는 경우도 많다. 위 연산 외에 중간에 위차하고 있는 값을 확인한다거나, 가장 아래의 원소를 제거 하는 등의다른 연산을 지원한다면 그것은 엄밀하게는 스택의 구조가 아니라고 할 수 있다.그러나 뭐 넓은 의미에서 위로 쌓이고 위에서부터 빠지고 하는 구조 자체를 말할때도 자주 사용한다. 2. 큐 (queue)2.1 개념큐는 스택과 달리 먼저 들어온 것이 먼저 나가는 구조이다.대표적으로 그냥 놀이공원 같은 곳에서 줄을 섰을 때를 생각하면 되는데,오래기다린 순서대로, 즉 앞에서 부터 처리되는 자료구조이다. 큐는 FIFO(FIRST IN FIRST OUT) 구조라고 불리기도 한다.큐는 위로 쌓는 이미지보다는 뒤로 원소들이 누적되고, 앞에서 부터 제거되는 이미지를 떠올리면 좋다. 운영체제가 프로세스들을 스케일링할 때 큐를 이용한다.(물론 그냥 큐는 아니고 큐의 응용이다.) 2.2 지원하는 연산 push : 큐의 가장 뒤에 값 추가 pop : 큐의 처음 값 제거 (이때 그 값을 return 해주기도 한다. back : 큐의 가장 마지막 값 반환 fromt : 큐의 가장 처음 값 반환 back의 경우 큐에서 무조건 지원해야 하는 내용은 아니지만c++의 queue 라이브러리에서 제공하기 때문에 적어두었다.스택과 비슷한 이름의 연산을 사용하지만, 아래서 부터 빠진다고 하는 경우는 거의 없기 때문에,마지막에 값을 추가하고, 앞에서부터 값이 제거된다고 생각하면 된다. 3. 덱 (deque)3.1 개념deque은 double ended queue, 즉 ‘양쪽이 끝인 큐’라는 말이다.따라서 양쪽에서 끝에서 값을 추가하고 제거하는 연산이 가능하다. 3.2 지원하는 연산 push_back : 덱의 가장 뒤에 값 추가 push_front : 덱의 가장 처음에 값 추가 pop_back : 덱의 마지막 값 제거 pop_front : 덱의 처음 값 제거 back : 덱의 마지막 값 반환 front : 덱의 처음 값 반환 at : index로 덱의 원소에 접근 at의 경우 덱에서 무조건 지원해야 하는 내용은 아니지만c++의 deque 라이브러리에서 지원하고 있기 때문에 적어두었다. 그렇다면 스택이나 큐보다 무조건 덱을 사용하는 것이 좋은 것 아닌가? 라고 생각 할 수 있다.하지만 필요없는 연산을 굳이 구현할 필요가 없을 수도 있고, 연산을 일부로 제한 해 둘 필요가 있을 수도 있다. 마무리스택과 큐 그리고 덱은 알고리즘 문제풀이를 위한 자료구조이기도 하지만컴퓨터공학의 전반적인 분야에서 설명을 할때 매우 자주 사용되는 내용이다. 따라서 당장의 필요가 없다하더라도, 그리고 구현을 직접 해보지 않더라도내용만 미리알아두는 정도로도 충분히 의미있다.","link":"/2021/08/18/ds-al-2/"},{"title":"cplus_typecasting","text":"어제 알고리즘을 풀다가 실수할만한 부분을 발견해서 짧게 정리한다.int형과 double형을 혼용해서 쓰면서 발생한 문제인데, 예시를 통해 설명해보겠다.어렵지 않고 매우 간단한 내용이다. 예시123456int main(void){ int a = 10 - (3 / 2); printf(&quot;%d&quot;, a);} 위 코드가 실행 되었을 때 출력되는 값은 9 이다.3 / 2 = 1.5 에서 0.5를 버리기 대문에 10 - 1 = 9 로 계산이 된다. 123456int main(void){ int a = 10 - (3.0 / 2); printf(&quot;%d&quot;, a);} 그런데 위 코드가 실행 되었을 때 출력되는 값은 8 이다.3.0 / 2 = 1.5로 계산이 되고, 10 - 1.5 = 8.5 로 계산이 된 후 0.5를 버리기 때문이다. 123456int main(void){ int a = 10 - int(3.0 / 2); printf(&quot;%d&quot;, a);} 이 코드는 3.0 / 2 의 결과인 1.5를 int형으로 바꿔버린 것이다.이렇게 바꾸면 다시 첫번째 결과와 동일하게 9를 출력한다. 내가 마주한 상황타입 변환에 관련 된 내용이라 나도 어느정도 아는 내용이였지만,내가 마주한 상황에서 생각하지를 못했다. &lt;math.h&gt;에서 pow()함수를 이용해서 제곱을 계산하였는데, 이 때의 return 값이 double이였다.그래서 위와 비슷한 예시에서 원하는 값을 얻지 못했다. 결론int 형과 double 형의 계산에서는int 형이 더 큰 메모리 공간을 갖는 double형으로 변환되어 계산된다.만약 그 후 대입 연산자가 있다면 대입연산자에 의해서 double 형이 int 형으로 자동형변환 되어 소수점을 버린다. 원하는 값을 얻기위해서는 필요한 순간에 강제 타입변환을 하거나, 모든 변수를 double형으로 통일한후에 원하는 타입으로 변환할 수 있다.","link":"/2021/08/24/cplus-typecasting/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"스택","slug":"스택","link":"/tags/%EC%8A%A4%ED%83%9D/"},{"name":"큐 - 덱","slug":"큐-덱","link":"/tags/%ED%81%90-%EB%8D%B1/"},{"name":"짧 - 자료형 - 타입변환","slug":"짧-자료형-타입변환","link":"/tags/%EC%A7%A7-%EC%9E%90%EB%A3%8C%ED%98%95-%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"자료구조&#x2F;알고리즘","slug":"자료구조-알고리즘","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"c++","slug":"c","link":"/categories/c/"}]}