{"pages":[{"title":"about","text":"안녕하세요.종민짱입니다. 연락은 jongminzzang97@gmail.com로 부탁드립니다.몇 시간내에 확인합니다.","link":"/about/index.html"},{"title":"blogmap","text":"블로그의 글이 어떤 카테고리 내에서 작성되었는지 보기 쉽게 정리하였습니다.작성된 글은 클릭을 통해 확인할 수 있습니다. 아직 작성되지 않은 글이 대부분이며, 작성된 글의 내용도 수시로 변경될 수 있습니다.ㅎㅎㅎ what / how (long)공부하면서 막혀서 찾아본 내용, 알고있었지만 정리하고 싶었던 부분을 정리합니다. 개요 question (short)위와 비슷하지만 짧게 정리 되는 글 입니다. 개요 자료구조/알고리즘사실은 코딩테스트를 위한…. 개요 자료구조 / 알고리즘 1 (리스트, 스택, 큐) 자료구조 / 알고리즘 2 (트리, 힙) 심화 자료구조 / 알고리즘 3 (세그먼트 트리) 동적계획법 내가 푼 문제들 -&gt; git project진행한 프로젝트입니다.학교에 과제로 진행했던 작은 규모의 프로젝트가 많습니다.","link":"/blogmap/index.html"},{"title":"algorithm","text":"알고리즘입니다. 문제를 클릭하면 github주소로 ★의 개수는 중요도가 아닌내가 배운 것이 많고 정리해 놓은 내용이 얼마나 많은가임 프로그래머스level1_내적level1_없는 숫자 더하기level2_가장 큰 수★★level2_전화번호 목록★★","link":"/algorithm/index.html"}],"posts":[{"title":"Hi, blog start!","text":"시작드디어 블로그를 만들었다. 생각보다 블로그를 만드는 것이 쉽지 않았다. using hexo네이버 블로그는 컴퓨터 분야와 잘 맞지 않는다고 생각했고, 티스토리는 최근에 속도가 좀 느려지고 이용률이 줄고 있다고 느꼈다. 많은 사람들이 github 주소의 블로그를 가지고 있는 것을 보며 나도 github pages를 이용해서 블로그를 만들기로 마음을 먹었다. github pages를 이용하여 블로그를 만드는 방법은 주로 아래 3가지 방법 중 하나이다. 직접 코딩 jekyll을 이용 hexo를 이용 일단 jekyll이나 hexo는 조금의 차이는 있지만 다른 사람이 만들어 놓은 테마를 이용하는 것이다.따라서 매우 간단하게 만들 수 있으며, post를 markdown으로 작성할 수 있다.markdown으로 작성하면서 또 하나의 좋은점은 내가 작성한 글들을 md파일로 저장하고 있으면블로그를 옮기더라도 바로 이전 글을 업로드 할 수 있다는 점이다. 직접 코딩을 한다면 내가 원하는 데로 만들 수 있다는 것이 가장 큰 장점이다.그러나 단순히 공부한 것을 정리하기 위한 블로그를 직접 만드는 것은 너무 귀찮다. 처음에는 jekyll을 이용하고자 하였다. 그리고 어렵지 않게 만들었다.근데 자꾸 사소한 오류가 발생하고 조금씩 마음에 들지 않는 부분이 있어서 그냥 처음부터 만들까 시도도 했지만,너무 해야될 일이 많아지는 것 같아 결국 hexo를 이용하게 되었다. 결과적으로 jekyll, hexo 모두를 이용해보면서 사소한 차이점을 찾았다.jekyll을 이용할 때에는 markdown으로 작성한 파일을 github에 push하기만 하면 된다.실제로 gitclone으로 jekyll의 설치없이 테마만 다운받고 markdown만 작성해도 이용할 수 있다. 반면 hexo는 generate, deploy 명령어를 이용한다.즉 github에 내가 작업한 폴더가 그대로 올라가는 것이 아니라 작업 폴더를 이용해 웹을 생성하고 그 웹을 github에 올린다.generate과정에서 md파일을 html로 변환하고 config.yml의 정보들이 이용된다.즉 markdown을 이용하여 작성한 post와 config.yml등은 github에 같이 업로드 되지 않는다. 블로그를 만들면서 참고한 것기본적으로는 유튜브 영상을 보면서 따라했고, 밑의 블로그의 글도 정말 도움도 많이 받았다. 카인드페밀리 - 오늘 부터 나도 github.io 블로그 운영자다!! | github pages , goormide, hexo 멋진 깃허브 블로그 시작하기","link":"/2021/08/09/hi/"},{"title":"자료구조 &#x2F; 알고리즘 개요","text":"힉교에서 2학년 1학기때 자료구조를 배우고 2학기에 알고리즘을 배웠다.이번에 삼성알고리즘 특감에 참여하면서 여태까지 배운 내용을 정리해보고자 한다. 자료구조 수업에서는 c언어로 자료구조들을 구현해보는 정도였다.큐, 스택, 연결리스트, 트리 등을 구조체로 구현하면서 포인터 사용법도 익히고 코딩하는 법도 배웠다.그리고 강의가 끝나고는 결국 연결리스트가 전부 아닌가? 라는 생각을 가졌다. 알고리즘 수업에서는 문제를 코드로 구현하는 것 보다는,하나의 어려운 문제를 어떻게 해결해 나갈 수 있을지에 대해서 배웠다. 사실 두 수업을 들었다고는 하나 문제를 풀어본 적은 거의 없었고,4학년이 돼서 취업을 위해 코딩테스트를 봐야 하는 상황에 놓이고 다시 공부를 했다.공부를 해보니 내가 생각했던 것 보다 공부해야 할 내용도 많았고,내용을 알고있더라도 실제로 푸는 것은 쉽지 않았다. 그러다 이번에 삼성SDS에서 진행한 2021 하계알고리즘 특강에 참여하게 되었다.이 수업을 들으면서 전체적으로 자료구조와 알고리즘에 대한 생각이 많이 정리 되었다.(알고리즘 특강에 대해서는 따로 글을 작성할 수 있으면 작성하겠다.)아무튼 스스로 한번 정리해보면 좋을 것 같아서 정해놓은 목차에 따라 글을 작성해보려고 한다.","link":"/2021/08/11/ds-al-outline/"},{"title":"자료구조 &#x2F; 알고리즘 1 (리스트 - 배열, 연결리스트)","text":"들어가기기본적인 자료구조인 리스트 스택 큐에 대해서 다뤄본다.너무 쉽고 기초적인 내용이지만 그 만큼 많은 분야에서 사용되며, 이 내용을 알아야 다른 내용 또한 이해할 수 있다. 리스트를 구현하는 두 가지 방법인 배열과 연결리스트는 다른 자료구조를 구현 할 때 계속 사용된다.따라서 확실히 공부해둔다면 다른 자료구조를 쉽게 배울 수 있다고 생각한다. 본격적인 내용시작전에 말을 조금 더하자면,자료구조마다 사용하는 연산(함수)가 다르고 연산의 속도또한 다르다. 그렇기 때문에 자료구조마다 사용되는 곳이 다르다. 특정한 상황에 알맞은 자료구조를 사용하는 지를 선택하는 것은,코드를 작성할 때도 편리함을 제공하지만 결과적으로 프로그램의 속도에까지 영향을 줄 수 있다.(그렇기에 알고리즘 문제를 풀 때 자료구조를 잘 선택해야 한다.)따라서 각각의 자료구조가 어디서 이용될 수 있는지 생각해보는 것도 중요하다. 내가 학교에서 자료구조 강의를 들었을 때는 삽입, 삭제, 검색, 정렬 등의 함수를 구형하는 것이 과제였는데,한번 구현해 보는 것도 도움이 될 수 있겠다고 생각한다. 리스트리스트는 선형구조로 원소들이 제시되는 상황에서 많이 사용된다.그리고 실제로 다루게될 대부분에 데이터들은 리스트의 형태이다. 리스트로 주어지는 데이터를 컴퓨터에서 저장할 때는 주로 두 가지 방법을 이용한는데,하나는 배열 그리고 다른 하나는 연결리스트다. 다른 자료구조들을 이 두가지 자료구조를 이용하여 구현되기 때문에 이 둘을 정확히 아는 것이 중요하다. 배열(array)배열을 선언하면 실제 컴퓨터 상에 연속한 공간에 데이터들이 배치되었다 생각할 수 있다.이 사실이 매우 중요한데, 이는 내가 접근하고자 하는 원소의 주소를 바로 계산가능하게 해주기 때문이다. 어떤 타입의 배열일수도, 어떤 클레스의 배열일수도 있지만 하나의 원소의 크기는 일정하다.그렇기에 배열의 시작주소에, 원소하나의 크기 그리고 접근하고자 하는 원소의 순서를 곱해서 더하면 주소값을 바로 구할 수 있다.즉 (배열의 시작주소) + sizeof(t1)*x 를 통해 값에 바로 접근이 가능하다.이는 index로 원소에 접근할 때 O(1)만에 가능함을 보여준다. 반면 배열 중간에 어떤 원소를 삽입할 때는 조금 번거로운데,삽입하려는 위치보다 뒤에 있는 원소들을 모두 한칸씩 뒤로 이동시키는 과정이 선행되어야 한다.마찬가지로 원소를 삭제할 때도 삭제한 후 뒤에 있는 원소들을 한칸씩 앞으로 이동시켜야 한다. 연결리스트(linked list)연결리스트의 아이디어는 구조체가 값과 다음 원소의 위치 정보를 저장하고 있는 것이다.(많은 사람들이 손을 잡고 일렬로 서있는 것을 생각해 볼 수 있다.)노드라는 구조체를 주로 이용하는데, 노드는 자신의 값(value)와 다음 노드의 주소값을 원소로 갖는다. 어떤 원소에 접근하는 것 부터 배열과 차이를 보인다.만약 내가 index로 연결리스트의 어떤 원소에 접근하려면,첫 번째 노드에 접근하여 두 번째 노드의 주소를 찾고, 두 번재 노드에 접근하여 세 번째 노드의 주소를 찾고와같은 과정을 loop을 통해 반복해야 한다. 리스트 가운데에 원소를 삽입하거나, 중간에 위치한 원소를 삭제할 때 배열보다 연결리스트가 유리하다.그 원소의 위치를 찾을 때 까지는 위에서 언급한 방법으로 찾아야 하지만, 노드를 삭제할 때는 삭제하려는 노드의 이전 노드의 주소 값을 삭제하려는 노드의 다음 원소의 주소값으로 바꿔주면 된다.원소를 삽입할 때는 이전 원소가 갖고 있던 다음 원소의 주소값을 새 노드에게 알려주고,이전 노드에는 새 노드의 주소값을 저장하도록 해준다.말로 하면 어려워 보이지만 그림을 보면 이해하기 어렵지 않다. linked list의 종류가 몇가지 있다.노드가 이전 노드의 주소를 저장하도록 구현하면 이용할 때 조금 유리한 부분이 있는데,이렇게 구현된 linked list는 이중연결리스트라고 한다.그리고 끝나는 노드가 시작 노드의 주소값을 저장하고 있으면,원형연결리스트라고 한다.","link":"/2021/08/15/ds-al-1/"},{"title":"자료구조 &#x2F; 알고리즘 2 (스택, 큐, 덱 )","text":"이전 글에서 언급했다 싶이 스택, 큐, 덱은 모두 선형 구조인 리스트의 일부이다.다만 세 자료구조는 지원하는 연산이 다르다.스택과 큐는 서로 비슷하지만 반대된다고 생각할 수 있으며, 덱은 둘을 합쳐 놓았다고 볼 수 있다.어려운 내용은 아니니 쉽게 이해할 수 있을 것이다. 1. 스택 (stack)1.1 개념게임을 조금 해본 사람들은 스택을 쌓는다는 표현을 들어봤을 수 있다.스택을 배우고 나면 이 표현이 어느정도 알맞는 표현이였다고 생각하게 될 수도 있다. 스택은 들어오는 곳과 나가는 곳이 동일한 선형 구조이다.즉 뒤에 들어온 원소들이 나가줘야만 앞에 있는 원소들이 스택에서 나갈 수 있다.늦게 들어온 것이 먼저 나간다는 의미로 영어에서는 LIFO(LAST IN FIRST OUT) 라는 말을 사용한다.(스택을 설명하기 위해 자주 드는 예시는 프링글즈 통이다.) 스택은 아래서 부터 위로 쌓는 이미지로 생각해도 좋고,앞에서 부터 뒤로 쌓는 이미지로 생각해도 좋다.다만 중요한 것은 위에서 부터 혹은 뒤에서 부터, 즉 쌓인 원소부터 제거된다는 것이다. 스택이 활용되는 가장 대표적인 부분은함수들이 함수들을 실행하고, 프로그램이 프로그램을 실행할때스택에 쌓아가면서 실행하고 종료될 때는 위에 부터 종료되게 함으로 써내부의 함수 또는 프로그램이 외부의 함수 또는 프로그램 보다 먼저 종료되게 해준다. 1.2 지원하는 연산스택이 지원하는 연산은 크게 3가지 이다. push : 스택의 가장 뒤에 값 추가 // 스택의 가장 위에 값 추가 pop : 스택의 가장 마지막 값 제거 // 스택의 가장 위의 값 제거 top : 스택의 가장 마지막 값 반환 top은 사실 스택의 가장 위에 있는 원소를 말하는 것이지만, 연산의 이름으로 사용하는 경우도 많다. 위 연산 외에 중간에 위차하고 있는 값을 확인한다거나, 가장 아래의 원소를 제거 하는 등의다른 연산을 지원한다면 그것은 엄밀하게는 스택의 구조가 아니라고 할 수 있다.그러나 뭐 넓은 의미에서 위로 쌓이고 위에서부터 빠지고 하는 구조 자체를 말할때도 자주 사용한다. 2. 큐 (queue)2.1 개념큐는 스택과 달리 먼저 들어온 것이 먼저 나가는 구조이다.대표적으로 그냥 놀이공원 같은 곳에서 줄을 섰을 때를 생각하면 되는데,오래기다린 순서대로, 즉 앞에서 부터 처리되는 자료구조이다. 큐는 FIFO(FIRST IN FIRST OUT) 구조라고 불리기도 한다.큐는 위로 쌓는 이미지보다는 뒤로 원소들이 누적되고, 앞에서 부터 제거되는 이미지를 떠올리면 좋다. 운영체제가 프로세스들을 스케일링할 때 큐를 이용한다.(물론 그냥 큐는 아니고 큐의 응용이다.) 2.2 지원하는 연산 push : 큐의 가장 뒤에 값 추가 pop : 큐의 처음 값 제거 (이때 그 값을 return 해주기도 한다. back : 큐의 가장 마지막 값 반환 fromt : 큐의 가장 처음 값 반환 back의 경우 큐에서 무조건 지원해야 하는 내용은 아니지만c++의 queue 라이브러리에서 제공하기 때문에 적어두었다.스택과 비슷한 이름의 연산을 사용하지만, 아래서 부터 빠진다고 하는 경우는 거의 없기 때문에,마지막에 값을 추가하고, 앞에서부터 값이 제거된다고 생각하면 된다. 3. 덱 (deque)3.1 개념deque은 double ended queue, 즉 ‘양쪽이 끝인 큐’라는 말이다.따라서 양쪽에서 끝에서 값을 추가하고 제거하는 연산이 가능하다. 3.2 지원하는 연산 push_back : 덱의 가장 뒤에 값 추가 push_front : 덱의 가장 처음에 값 추가 pop_back : 덱의 마지막 값 제거 pop_front : 덱의 처음 값 제거 back : 덱의 마지막 값 반환 front : 덱의 처음 값 반환 at : index로 덱의 원소에 접근 at의 경우 덱에서 무조건 지원해야 하는 내용은 아니지만c++의 deque 라이브러리에서 지원하고 있기 때문에 적어두었다. 그렇다면 스택이나 큐보다 무조건 덱을 사용하는 것이 좋은 것 아닌가? 라고 생각 할 수 있다.하지만 필요없는 연산을 굳이 구현할 필요가 없을 수도 있고, 연산을 일부로 제한 해 둘 필요가 있을 수도 있다. 마무리스택과 큐 그리고 덱은 알고리즘 문제풀이를 위한 자료구조이기도 하지만컴퓨터공학의 전반적인 분야에서 설명을 할때 매우 자주 사용되는 내용이다. 따라서 당장의 필요가 없다하더라도, 그리고 구현을 직접 해보지 않더라도내용만 미리알아두는 정도로도 충분히 의미있다.","link":"/2021/08/18/ds-al-2/"},{"title":"cplus_typecasting","text":"어제 알고리즘을 풀다가 실수할만한 부분을 발견해서 짧게 정리한다.int형과 double형을 혼용해서 쓰면서 발생한 문제인데, 예시를 통해 설명해보겠다.어렵지 않고 매우 간단한 내용이다. 예시123456int main(void){ int a = 10 - (3 / 2); printf(&quot;%d&quot;, a);} 위 코드가 실행 되었을 때 출력되는 값은 9 이다.3 / 2 = 1.5 에서 0.5를 버리기 대문에 10 - 1 = 9 로 계산이 된다. 123456int main(void){ int a = 10 - (3.0 / 2); printf(&quot;%d&quot;, a);} 그런데 위 코드가 실행 되었을 때 출력되는 값은 8 이다.3.0 / 2 = 1.5로 계산이 되고, 10 - 1.5 = 8.5 로 계산이 된 후 0.5를 버리기 때문이다. 123456int main(void){ int a = 10 - int(3.0 / 2); printf(&quot;%d&quot;, a);} 이 코드는 3.0 / 2 의 결과인 1.5를 int형으로 바꿔버린 것이다.이렇게 바꾸면 다시 첫번째 결과와 동일하게 9를 출력한다. 내가 마주한 상황타입 변환에 관련 된 내용이라 나도 어느정도 아는 내용이였지만,내가 마주한 상황에서 생각하지를 못했다. &lt;math.h&gt;에서 pow()함수를 이용해서 제곱을 계산하였는데, 이 때의 return 값이 double이였다.그래서 위와 비슷한 예시에서 원하는 값을 얻지 못했다. 결론int 형과 double 형의 계산에서는int 형이 더 큰 메모리 공간을 갖는 double형으로 변환되어 계산된다.만약 그 후 대입 연산자가 있다면 대입연산자에 의해서 double 형이 int 형으로 자동형변환 되어 소수점을 버린다. 원하는 값을 얻기위해서는 필요한 순간에 강제 타입변환을 하거나, 모든 변수를 double형으로 통일한후에 원하는 타입으로 변환할 수 있다.","link":"/2021/08/24/cplus-typecasting/"},{"title":"자료구조 &#x2F; 알고리즘 3 (그레프, 트리, 힙)","text":"이전까지 다뤘던 자료구조와는 다르게 트리느 비선형 구조이다.선형적으로 즉 일렬로 데이터들이 있는 것이 아니다.대신에 트리는 계층적 구조라고 말하는데 이것이 선형구조의 반대되는 개념은 아니다.트리의 구조는 그림을 보면서 이해하는 것이 빠르다. 1. 그래프1.1 개념고등학교 때 까지 수학에서 다뤄왔던 그래프와는 좀 다르다.그래프란 정점(Vertex)와 간선(Edge)로 이루어진 자료구조를 말한다. 2. 트리2.1 개념트리는 특수한 그래프이다.그래프가 생긴 모양이 나무와 같아서 트리라는 이름이 붙었다. 그래프는 정점(Node)와 간선(Edge)로 이루어 진다는 것이 특징인데,트리는 한 정점에서 다른 정점까지의 길이 하나 뿐이라는 것이 특징이다.(조금 생각해보면 사이클이 존재하지 않는다는 것과 동의어임을 알 수 잇다.) &lt;그림&gt; 트리는 일반적으로 위와 같은 그림으로 표현된다. 트리의 하나의 정점 즉 노드는 부모 노드와 자식 노드를 갖는다.부모노드는 하나여야만 하고, 자식노드는 몇개든 상관없고 없어도 된다.최상단의 부모가 없는 노드를 루트 노드라고 한다. 2.2 용어 노드 : 하나의 값을 갖는 정점. 하나의 부모노드와 여러개의 자식노드를 갖을 수 있다. 간선 : 노드와 노드를 잇는 선분. 간선이 방향을 갖는 경우도 있다. 루트 노드 : 최상단의 노드로 부모노드를 갖지 않는다. 부모노드 / 자식노드 : 두 노드의 관계에서 위에 있는 노드르 부모노드, 아래있는 노드를 자식노드라고 부른다. 조상노드 : 부모 노드를 따라가다 보면 나오는 노드들을 말한다. 2. 힙","link":"/2021/08/29/ds-al-3/"},{"title":"실내&#x2F;실외&#x2F;음식 구분 - 프로젝트","text":"들어가며작년에 수업에서 진행했던 프로젝트를 정리해볼것이다. 코드가 길지 않고 간단하지만 내용으로 보면 쉽지 않고한학기 동안 실습했던 내용을 담고 있어서 배웠던 내용을 정리하는 데에 매우 도움이 되었다. 그때 진행했던 프로젝트를 리뷰하면서 복습해볼 생각이다. 프로젝트의 목표음식, 식당의 내부, 식당의 외부 중 하나에 속하는 이미지가 주어졌을 때,어디에 속하는 이미지인지 판단할 수 있는 모델을 만든다. 모델의 정확도는 높을수록 좋다. 이용할 데이터음식사진 20000장, 식당 내부사진 15000장, 식당 외부사진 10000장을 제공받았다.(수업을 듣는 학생들이 몇백장정도씩 직접 분류하였다.) 이 이미지들을 이용하여 학습하고 모델을 생성한다. 전체 코드많은양의 코드가 아니란 것을 보여주기 위해 전체코드부터 제공한다. 짧게 전체적인 과정을 먼저 설명하자면 다음과 같다. 모델 만들기 (함수) 그래프 그리기 (함수) 이미지 읽어오기 학습 코드 확인 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import numpy as npimport osimport matplotlib.pyplot as pltfrom tensorflow.keras.models import Sequential, load_modelfrom tensorflow.keras.layers import Input, Dense, Conv2D, MaxPooling2D, Flatten, BatchNormalizationfrom keras.utils import np_utils, to_categorical,multi_gpu_modelfrom keras.datasets import mnistfrom keras.preprocessing.image import array_to_img, img_to_array, load_imgfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_splitdef gen_sequential_model(): model = Sequential([ Input(shape=(300,300,3), name = 'input_layer'), BatchNormalization(), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer1'), MaxPooling2D(pool_size=(2,2)), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer2'), MaxPooling2D(pool_size=(2,2)), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer3'), MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer4'), #MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer5'), MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer6'), MaxPooling2D(pool_size=(2,2)), Flatten(), Dense(3, activation='softmax', name='output_layer') ]) model.compile(optimizer='adam', loss='categorical_crossentropy',metrics=['accuracy']) #model = keras.utils.multi_gpu_model(model, gpus=4) model.summary() return modeldef plot_loss_curve(history): import matplotlib.pyplot as plt plt.figure(figsize=(15, 10)) plt.plot(history.history['loss'][1:]) plt.plot(history.history['val_loss'][1:]) #plt.plot(history.history['val_loss'][1:]) plt.title('model loss') plt.ylabel('loss') plt.xlabel('epoch') plt.legend(['train', 'test'], loc='upper right') plt.show() #이거 캡쳐하기 path = r&quot;C:\\Users\\이종민&quot;trainFileList = os.listdir(path)trainFileList = [x for x in trainFileList if 'jpg' in x]train_datagen = ImageDataGenerator()training_set = train_datagen.flow_from_directory(path+&quot;\\images_train&quot;, target_size = (300, 300), batch_size = 32, class_mode = 'categorical')test_datagen = ImageDataGenerator()test_set = test_datagen.flow_from_directory(path+&quot;\\images_test&quot;, target_size = (300, 300), batch_size = 32, class_mode = 'categorical')model = gen_sequential_model()history = model.fit(training_set,steps_per_epoch=30, epochs=50, validation_data=test_set)model.save('이종민-2017114152')plot_loss_curve(history)print(history.history)print(&quot;train loss=&quot;, history.history['loss'][-1])print(&quot;test loss=&quot;, history.history['val_loss'][-1])print(test_set.class_indices)print(training_set.class_indices)","link":"/2021/09/03/image-classification-project/"},{"title":"앞으로 할것 정리","text":"들어가며해야 될 것은 많은데 잘 안하게 되는것 같아서 뭘 할지 정리해보고자 한다.블로그를 시작하고 커밋만 집착하게 되고 글을 완성하지는 못하는 것 같다. 1. 블로그 포스팅블로그를 생성하고 꾸준히 해보고자 했는데 생각보다 잘 못하고 있다.글은 작성하여보니 마음에 들지도 않고 사진이나 코드도 첨부해야 하는데 생각보다 쉽지 않았다. 따라서 의무적으로 일주일에 글을 한 개씩 작성하기로 했다.의무적인 것만 긴 글 하나이고 짧은 글은 수시로 작성한다.긴 글의 내용은 주로 여태까지 배운 내용 정리나, 새로 많은 내용을 배우게 되었을 때의 정리 일 것이고간단하게 알게된 정보는 짧게 포스팅 하겠다. 2. 알고리즘 문제방학때 삼성 알고리즘 특강을 들을 때 조금 풀다가 다시 열심히 안하고 있다. 안풀리면 짜증나고 풀고나서 다시 정리하기도 싫어서 그런것 같은데, 일단 나에게 가장 중요하다고 생각됨으로 일주일에 5문제씩 풀기로 했다.(사실 몇문제 보다 어느 정도의 난이돈지가 중요하다고 생각한다.) 3. 졸작(졸프) 공부이번에 졸업프로젝트를 들으면서 공부해야 될 부분이 많다.아직 부족한 부분도 많고 진행한 부분도 없는데 시간도 많지 않다. 팀원들에게 민폐가 되지 않도록 공부를 해야한다. 4. 친구와 프로젝트해오고 싶은 아이디어는 있었는데 같이 할 사람이 없어 계속 미루다가 이번에 전역한 친구와 같이 하기로 했다.일주일에 한번씩 만나 상의하며 진행할 예정이고 전체적인 진행과정을 블로그에 올리는 것이 목표이다. 어설프겠지만 학습에 목적이 있는만큼 많은 부분을 배울 수 있었으면 한다. 5. 스프링 강의스프링 공부하려고 강의를 결제한 것이 있는데 빨리 들어야겠다.뭐 다른 강의도 듣긴 했지만 듣는건 쉬운데 바꿔가며 따라하고 익히는 부분이 어렵다. 졸프와 친구와 진행하는 프로젝트에서도 필요하기 때문에 빨리 익힐 필요가 있을 것 같다. 6. 일주일 정리배운 내용이 너무 간단한 내용이라 글을 작성하기 애매한 부분도 있고배운 내용이 없다고 생각해서 글을 작성하지 않을 때도 있다. 배운 내용을 정리하기 그러면 뭘 했는지라도 정리해서 올리고자 한다.그러면서 어느 정도 배운 내용을 상기할 수도 있고 꾸준히 공부를 이어갈 수 있을 것 같다.일요일마다 일주일을 정리하는 의미에서 일주일 요약을 작성하겠다. 요약 블로그 1주일 1포스팅 알고리즘 1주일 5문제 졸프 공부 친구와 프로젝트 1주일 1포스팅(진행 과정) 스프링 강의 - 따라하며 익히기 일주일 공부내용 매주 정리하기 되면 할거 -&gt; 영어공부, 컴퓨터 정리하고 포멧, 정리안된 글들 마무리 끝으로해야될걸 적어보니 더 많은것 같다. 아무튼 정리했으니 열심히 해보는걸로…","link":"/2021/09/06/to-do-2021/"},{"title":"GCD(Greatest common divisor) 알고리즘","text":"GCD(Greatest common divisor) 알고리즘사실 알고리즘이라기도 애매할 정도로 쉬운 내용이다.내용은 쉬운데 꾸준히 나오며, 안배우고 처음에 이 방법을 생각해내긴 쉽지 않다.정리하면서 그냥 외우려고 작성한다. 설명A와 B의 최대공약수를 구해보자. A = ac, B = bc 이며 c는 최대공약수라 가정해보자.A &gt; B 라고 한다면 A와 B의 관계식을 다음과 같이 작성해 볼 수 있다.ac = k * bc + X (이때 k는 상수이며 X는 나머지 이다.) 우변이 c로 나눠지므로 X로 c로 나눠떨어져야 한다.ac = k * bc + X-&gt; ac = k * bc + xc 와 같이 식을 작성할 수 있다. 그러면 여기서 b와 x는 c라는 약수를 공유한다.따라서 bc와 xc의 최대공약수를 구함으로써 ac와 bc의 최대공약수를 구할 수 있다는 것이 아이디어이다. 그런데 bc와 xc의 최대공약수가 ac와 bc의 최대공약수임을 보장할 수 있는가?b와 x가 약수를 갖을 수도 있는것 아닌가?b와 c가 또다른 약수 d를 갖는다고 해보자. 그럼 식은 다음과 같이 바뀔 수 있다.ac = k * b’cd + x’cd만약 이런식으로 작성된다면 우변은 cd로 묶일 수 있다.그렇다면 좌변도 마찬가지로 cd로 나눠질 수 있어야 한다.a’cd = k * b’cd + x’cd따라서 여기서의 최대공약수는 cd이므로 A와 B의 최대공약수는 c라는 가정에 모순된다. 위의 과정을 반복하면서 X가 0일때,즉 나머지가 없을때의 작은수가 최대공약수가 된다. 매우쉬운 내용인데 글로 쓰니까 길기만 길다. 코드123456789101112131415161718def gcd(A, B): if B &gt; A: A, B = B, A if B &lt; 1: return 0 while(True): X = A % B if X == 0: break A = B B = X return B","link":"/2021/10/21/gcd-algorithm/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"스택","slug":"스택","link":"/tags/%EC%8A%A4%ED%83%9D/"},{"name":"큐 - 덱","slug":"큐-덱","link":"/tags/%ED%81%90-%EB%8D%B1/"},{"name":"짧 - 자료형 - 타입변환","slug":"짧-자료형-타입변환","link":"/tags/%EC%A7%A7-%EC%9E%90%EB%A3%8C%ED%98%95-%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98/"},{"name":"트리","slug":"트리","link":"/tags/%ED%8A%B8%EB%A6%AC/"},{"name":"프로젝트","slug":"프로젝트","link":"/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"머신러닝","slug":"머신러닝","link":"/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"이미지 분류","slug":"이미지-분류","link":"/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%84%EB%A5%98/"},{"name":"to-do","slug":"to-do","link":"/tags/to-do/"},{"name":"gcd","slug":"gcd","link":"/tags/gcd/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"자료구조&#x2F;알고리즘","slug":"자료구조-알고리즘","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"프로젝트","slug":"프로젝트","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"to-do","slug":"to-do","link":"/categories/to-do/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]}