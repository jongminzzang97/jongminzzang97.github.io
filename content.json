{"pages":[{"title":"about","text":"안녕하세요.종민짱입니다. 연락은 jongminzzang97@gmail.com로 부탁드립니다.몇 시간내에 확인합니다.","link":"/about/index.html"},{"title":"blogmap","text":"블로그의 글이 어떤 카테고리 내에서 작성되었는지 보기 쉽게 정리하였습니다.작성된 글은 클릭을 통해 확인할 수 있습니다. 아직 작성되지 않은 글이 대부분이며, 작성된 글의 내용도 수시로 변경될 수 있습니다. what / how (long)공부하면서 막혀서 찾아본 내용, 알고있었지만 정리하고 싶었던 부분을 정리합니다. 개요 question (short)위와 비슷하지만 짧게 정리 되는 글 입니다. 개요 자료구조/알고리즘사실은 코딩테스트를 위한…. 개요 자료구조 / 알고리즘 1 (리스트, 스택, 큐) 자료구조 / 알고리즘 2 (트리, 힙) 심화 자료구조 / 알고리즘 3 (세그먼트 트리) 동적계획법 내가 푼 문제들 -&gt; git project진행한 프로젝트입니다.학교에 과제로 진행했던 작은 규모의 프로젝트가 많습니다.","link":"/blogmap/index.html"}],"posts":[{"title":"Hi, blog start!","text":"블로그 개설!!시작드디어 블로그를 만들었다. 마음처럼 블로그를 만드는 것이 쉽지않았다. using hexo네이버 블로그는 컴퓨터 분야와 잘 맞지 않는다고 생각했고, 티스토리는 최근에 서버상태가 좋지 않은 지 속도가 좀 느리고 이용률도 낮아지고 있다고 생각해서 github pages를 이용해서 블로그를 만들기로 마음을 먹었다. github pages를 이용하여 블로그를 만드는 방법은 1. 직접 코딩 2. jekyll을 이용 3. hexo를 이용이 대표적이인데 지금 이 블로그는 hexo icarus theme을 이용하여 생성한 블로그이다. 일단 jekyll이나 hexo는 조금의 차이는 있지만 다른 사람이 만들어 놓은 테마를 이용하면 되기에 매우 편리하다. 또한 post를 markdown으로 작성하기에 내가 md파일을 저장하고 있을 수 있다는 것이 큰 장점이라고 할 수 있다.(나중에 블로그의 테마를 바꾸거나, 프레임워크를 쉽게 바꿀 수 있다.)뭐 직접 만드는 것은 원하는 데로 만들 수 있다는 것이 장점이지만 당연히 하기가 힘들다. 그래서 직접만들 생각은 없었고 jekyll을 이용하고자 하였다. 그리고 뭐 어렵지 않게 만들 수 있었다. 근데 자꾸 사소한 오류가 발생하거나 조금씩 마음에 들지 않는 부분이 있어서 처음부터 만들어야겠다고 웹공부를 조금 했는데, 또 그러기에는 양이 너무 많을 것 같아 hexo를 이용한 마음에 드는 theme을 찾아서 시도하게 되었다. 결과적으로 jekyll, hexo 둘을 통해 블로그를 만들어보면서 조금의 차이점을 찾았다.jekyll은 그냥 markdown으로 작성한 파일을 github에 push하기만 하면 된다. 즉 내가 local에서 작업하는 파일, 폴더 그대로 github에 있다.반면 hexo는 generate, deploy 명령어를 이용한다. github에 내가 작업한 폴더가 그대로 올라가는 것이 아니라 작업한 폴더를 이용해 웹을 생성하고 그 웹을 업로드하는 것 같다. (generate과정에서 markdown파일이 html로 변환된 파일이 생성된다.) 그리고 config.yml의 정보또한 generate과정에 이용되어 github에 upload되지 않는다. 블로그를 만들면서 참고한 것기본적으로는 유튜브 영상을 보면서 따라했고, 밑의 블로그의 글도 정말 도움도 많이 받았다. 카인드페밀리 - 오늘 부터 나도 github.io 블로그 운영자다!! | github pages , goormide, hexo 멋진 깃허브 블로그 시작하기","link":"/2021/08/09/hi/"},{"title":"자료구조 &#x2F; 알고리즘 개요","text":"힉교에서 2학년 1학기때 자료구조를 배우고 2학기에 알고리즘을 배웠다.이번에 삼성알고리즘 특감에 참여하면서 여태까지 배운 내용을 정리해보고자 한다. 자료구조 수업에서는 c언어로 자료구조들을 구현해보는 정도였다.큐, 스택, 연결리스트, 트리 등을 구조체로 구현하면서 포인터 사용법도 익히고 코딩하는 법도 배웠다.그리고 강의가 끝나고는 결국 연결리스트가 전부 아닌가? 라는 생각을 가졌다. 알고리즘 수업에서는 문제를 코드로 구현하는 것 보다는,하나의 어려운 문제를 어떻게 해결해 나갈 수 있을지에 대해서 배웠다. 사실 두 수업을 들었다고는 하나 문제를 풀어본 적은 거의 없었고,4학년이 돼서 취업을 위해 코딩테스트를 봐야 하는 상황에 놓이고 다시 공부를 했다.공부를 해보니 내가 생각했던 것 보다 공부해야 할 내용도 많았고,내용을 알고있더라도 실제로 푸는 것은 쉽지 않았다. 그러다 이번에 삼성SDS에서 진행한 2021 하계알고리즘 특강에 참여하게 되었다.이 수업을 들으면서 전체적으로 자료구조와 알고리즘에 대한 생각이 많이 정리 되었다.(알고리즘 특강에 대해서는 따로 글을 작성할 수 있으면 작성하겠다.)아무튼 스스로 한번 정리해보면 좋을 것 같아서 정해놓은 목차에 따라 글을 작성해보려고 한다.","link":"/2021/08/11/ds-al-outline/"},{"title":"자료구조 &#x2F; 알고리즘 1 (리스트 - 배열, 연결리스트)","text":"들어가기기본적인 자료구조인 리스트 스택 큐에 대해서 다뤄본다.너무 쉽고 기초적인 내용이지만 그 만큼 많은 분야에서 사용되며, 이 내용을 알아야 다른 내용 또한 이해할 수 있다. 리스트를 구현하는 두 가지 방법인 배열과 연결리스트는 다른 자료구조를 구현 할 때 계속 사용된다.따라서 확실히 공부해둔다면 다른 자료구조를 쉽게 배울 수 있다고 생각한다. 리스트리스트는 선형구조로 원소들이 제시되는 상황에서 많이 사용된다.그리고 실제로 다루게될 대부분에 데이터들은 리스트의 형태이다. 리스트로 주어지는 데이터를 컴퓨터에서 저장할 때는 주로 두 가지 방법을 이용한는데,하나는 배열 그리고 다른 하나는 연결리스트다. 다른 자료구조들을 이 두가지 자료구조를 이용하여 구현되기 때문에 이 둘을 정확히 아는 것이 중요하다. 배열(array)배열을 선언하면 실제 컴퓨터 상에 연속한 공간에 데이터들이 배치되었다 생각할 수 있다.이 사실이 매우 중요한데, 이는 내가 접근하고자 하는 원소의 주소를 바로 계산가능하게 해주기 때문이다. 어떤 타입의 배열일수도, 어떤 클레스의 배열일수도 있지만 하나의 원소의 크기는 일정하다.그렇기에 배열의 시작주소에, 원소하나의 크기 그리고 접근하고자 하는 원소의 순서를 곱해서 더하면 주소값을 바로 구할 수 있다.즉 (배열의 시작주소) + sizeof(t1)*x 를 통해 값에 바로 접근이 가능하다.이는 index로 원소에 접근할 때 O(1)만에 가능함을 보여준다. 반면 배열 중간에 어떤 원소를 삽입할 때는 조금 번거로운데,삽입하려는 위치보다 뒤에 있는 원소들을 모두 한칸씩 뒤로 이동시키는 과정이 선행되어야 한다.마찬가지로 원소를 삭제할 때도 삭제한 후 뒤에 있는 원소들을 한칸씩 앞으로 이동시켜야 한다. 연결리스트(linked list)연결리스트의 아이디어는 구조체가 값과 다음 원소의 위치 정보를 저장하고 있는 것이다.(많은 사람들이 손을 잡고 일렬로 서있는 것을 생각해 볼 수 있다.)노드라는 구조체를 주로 이용하는데, 노드는 자신의 값(value)와 다음 노드의 주소값을 원소로 갖는다. 어떤 원소에 접근하는 것 부터 배열과 차이를 보인다.만약 내가 index로 연결리스트의 어떤 원소에 접근하려면,첫 번째 노드에 접근하여 두 번째 노드의 주소를 찾고, 두 번재 노드에 접근하여 세 번째 노드의 주소를 찾고와같은 과정을 loop을 통해 반복해야 한다. 리스트 가운데에 원소를 삽입하거나, 중간에 위치한 원소를 삭제할 때 배열보다 연결리스트가 유리하다.그 원소의 위치를 찾을 때 까지는 위에서 언급한 방법으로 찾아야 하지만, 노드를 삭제할 때는 삭제하려는 노드의 이전 노드의 주소 값을 삭제하려는 노드의 다음 원소의 주소값으로 바꿔주면 된다.원소를 삽입할 때는 이전 원소가 갖고 있던 다음 원소의 주소값을 새 노드에게 알려주고,이전 노드에는 새 노드의 주소값을 저장하도록 해준다.말로 하면 어려워 보이지만 그림을 보면 이해하기 어렵지 않다. linked list의 종류가 몇가지 있다.노드가 이전 노드의 주소를 저장하도록 구현하면 이용할 때 조금 유리한 부분이 있는데,이렇게 구현된 linked list는 이중연결리스트라고 한다.그리고 끝나는 노드가 시작 노드의 주소값을 저장하고 있으면,원형연결리스트라고 한다.","link":"/2021/08/15/ds-al-1/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"자료구조&#x2F;알고리즘","slug":"자료구조-알고리즘","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"}]}