{"pages":[{"title":"about","text":"안녕하세요.종민짱입니다. 연락은 jongminzzang97@gmail.com로 부탁드립니다.몇 시간내에 확인합니다.","link":"/about/index.html"},{"title":"blogmap","text":"블로그의 글이 어떤 카테고리 내에서 작성되었는지 보기 쉽게 정리하였습니다.작성된 글은 클릭을 통해 확인할 수 있습니다. 아직 작성되지 않은 글이 대부분이며, 작성된 글의 내용도 수시로 변경될 수 있습니다.ㅎㅎㅎ what / how (long)공부하면서 막혀서 찾아본 내용, 알고있었지만 정리하고 싶었던 부분을 정리합니다. 개요 question (short)위와 비슷하지만 짧게 정리 되는 글 입니다. 개요 자료구조/알고리즘사실은 코딩테스트를 위한…. 개요 자료구조 / 알고리즘 1 (리스트, 스택, 큐) 자료구조 / 알고리즘 2 (트리, 힙) 심화 자료구조 / 알고리즘 3 (세그먼트 트리) 동적계획법 내가 푼 문제들 -&gt; git project진행한 프로젝트입니다.학교에 과제로 진행했던 작은 규모의 프로젝트가 많습니다.","link":"/blogmap/index.html"},{"title":"algorithm","text":"알고리즘입니다.풀었던 모든 문제 중에 쉬우면서 배울게 많은 것만 적어두었습니다. 문제를 클릭하면 github주소로 ★의 개수는 중요도가 아닌내가 배운 것이 많고 정리해 놓은 내용이 얼마나 많은가임 프로그래머스level1_내적level1_없는 숫자 더하기level2_가장 큰 수★★level2_전화번호 목록★★ 예전에 정리하던 것들","link":"/algorithm/index.html"}],"posts":[{"title":"Hi, blog start!","text":"시작드디어 블로그를 만들었다. 생각보다 블로그를 만드는 것이 쉽지 않았다. using hexo네이버 블로그는 컴퓨터 분야와 잘 맞지 않는다고 생각했고, 티스토리는 최근에 속도가 좀 느려지고 이용률이 줄고 있다고 느꼈다. 많은 사람들이 github 주소의 블로그를 가지고 있는 것을 보며 나도 github pages를 이용해서 블로그를 만들기로 마음을 먹었다. github pages를 이용하여 블로그를 만드는 방법은 주로 아래 3가지 방법 중 하나이다. 직접 코딩 jekyll을 이용 hexo를 이용 일단 jekyll이나 hexo는 조금의 차이는 있지만 다른 사람이 만들어 놓은 테마를 이용하는 것이다.따라서 매우 간단하게 만들 수 있으며, post를 markdown으로 작성할 수 있다.markdown으로 작성하면서 또 하나의 좋은점은 내가 작성한 글들을 md파일로 저장하고 있으면블로그를 옮기더라도 바로 이전 글을 업로드 할 수 있다는 점이다. 직접 코딩을 한다면 내가 원하는 데로 만들 수 있다는 것이 가장 큰 장점이다.그러나 단순히 공부한 것을 정리하기 위한 블로그를 직접 만드는 것은 너무 귀찮다. 처음에는 jekyll을 이용하고자 하였다. 그리고 어렵지 않게 만들었다.근데 자꾸 사소한 오류가 발생하고 조금씩 마음에 들지 않는 부분이 있어서 그냥 처음부터 만들까 시도도 했지만,너무 해야될 일이 많아지는 것 같아 결국 hexo를 이용하게 되었다. 결과적으로 jekyll, hexo 모두를 이용해보면서 사소한 차이점을 찾았다.jekyll을 이용할 때에는 markdown으로 작성한 파일을 github에 push하기만 하면 된다.실제로 gitclone으로 jekyll의 설치없이 테마만 다운받고 markdown만 작성해도 이용할 수 있다. 반면 hexo는 generate, deploy 명령어를 이용한다.즉 github에 내가 작업한 폴더가 그대로 올라가는 것이 아니라 작업 폴더를 이용해 웹을 생성하고 그 웹을 github에 올린다.generate과정에서 md파일을 html로 변환하고 config.yml의 정보들이 이용된다.즉 markdown을 이용하여 작성한 post와 config.yml등은 github에 같이 업로드 되지 않는다. 블로그를 만들면서 참고한 것기본적으로는 유튜브 영상을 보면서 따라했고, 밑의 블로그의 글도 정말 도움도 많이 받았다. 카인드페밀리 - 오늘 부터 나도 github.io 블로그 운영자다!! | github pages , goormide, hexo 멋진 깃허브 블로그 시작하기","link":"/2021/08/09/hi/"},{"title":"자료구조 &#x2F; 알고리즘 개요","text":"힉교에서 2학년 1학기때 자료구조를 배우고 2학기에 알고리즘을 배웠다.이번에 삼성알고리즘 특감에 참여하면서 여태까지 배운 내용을 정리해보고자 한다. 자료구조 수업에서는 c언어로 자료구조들을 구현해보는 정도였다.큐, 스택, 연결리스트, 트리 등을 구조체로 구현하면서 포인터 사용법도 익히고 코딩하는 법도 배웠다.그리고 강의가 끝나고는 결국 연결리스트가 전부 아닌가? 라는 생각을 가졌다. 알고리즘 수업에서는 문제를 코드로 구현하는 것 보다는,하나의 어려운 문제를 어떻게 해결해 나갈 수 있을지에 대해서 배웠다. 사실 두 수업을 들었다고는 하나 문제를 풀어본 적은 거의 없었고,4학년이 돼서 취업을 위해 코딩테스트를 봐야 하는 상황에 놓이고 다시 공부를 했다.공부를 해보니 내가 생각했던 것 보다 공부해야 할 내용도 많았고,내용을 알고있더라도 실제로 푸는 것은 쉽지 않았다. 그러다 이번에 삼성SDS에서 진행한 2021 하계알고리즘 특강에 참여하게 되었다.이 수업을 들으면서 전체적으로 자료구조와 알고리즘에 대한 생각이 많이 정리 되었다.(알고리즘 특강에 대해서는 따로 글을 작성할 수 있으면 작성하겠다.)아무튼 스스로 한번 정리해보면 좋을 것 같아서 정해놓은 목차에 따라 글을 작성해보려고 한다.","link":"/2021/08/11/ds-al-outline/"},{"title":"자료구조 &#x2F; 알고리즘 1 (리스트 - 배열, 연결리스트)","text":"들어가기기본적인 자료구조인 리스트 스택 큐에 대해서 다뤄본다.너무 쉽고 기초적인 내용이지만 그 만큼 많은 분야에서 사용되며, 이 내용을 알아야 다른 내용 또한 이해할 수 있다. 리스트를 구현하는 두 가지 방법인 배열과 연결리스트는 다른 자료구조를 구현 할 때 계속 사용된다.따라서 확실히 공부해둔다면 다른 자료구조를 쉽게 배울 수 있다고 생각한다. 본격적인 내용시작전에 말을 조금 더하자면,자료구조마다 사용하는 연산(함수)가 다르고 연산의 속도또한 다르다. 그렇기 때문에 자료구조마다 사용되는 곳이 다르다. 특정한 상황에 알맞은 자료구조를 사용하는 지를 선택하는 것은,코드를 작성할 때도 편리함을 제공하지만 결과적으로 프로그램의 속도에까지 영향을 줄 수 있다.(그렇기에 알고리즘 문제를 풀 때 자료구조를 잘 선택해야 한다.)따라서 각각의 자료구조가 어디서 이용될 수 있는지 생각해보는 것도 중요하다. 내가 학교에서 자료구조 강의를 들었을 때는 삽입, 삭제, 검색, 정렬 등의 함수를 구형하는 것이 과제였는데,한번 구현해 보는 것도 도움이 될 수 있겠다고 생각한다. 리스트리스트는 선형구조로 원소들이 제시되는 상황에서 많이 사용된다.그리고 실제로 다루게될 대부분에 데이터들은 리스트의 형태이다. 리스트로 주어지는 데이터를 컴퓨터에서 저장할 때는 주로 두 가지 방법을 이용한는데,하나는 배열 그리고 다른 하나는 연결리스트다. 다른 자료구조들을 이 두가지 자료구조를 이용하여 구현되기 때문에 이 둘을 정확히 아는 것이 중요하다. 배열(array)배열을 선언하면 실제 컴퓨터 상에 연속한 공간에 데이터들이 배치되었다 생각할 수 있다.이 사실이 매우 중요한데, 이는 내가 접근하고자 하는 원소의 주소를 바로 계산가능하게 해주기 때문이다. 어떤 타입의 배열일수도, 어떤 클레스의 배열일수도 있지만 하나의 원소의 크기는 일정하다.그렇기에 배열의 시작주소에, 원소하나의 크기 그리고 접근하고자 하는 원소의 순서를 곱해서 더하면 주소값을 바로 구할 수 있다.즉 (배열의 시작주소) + sizeof(t1)*x 를 통해 값에 바로 접근이 가능하다.이는 index로 원소에 접근할 때 O(1)만에 가능함을 보여준다. 반면 배열 중간에 어떤 원소를 삽입할 때는 조금 번거로운데,삽입하려는 위치보다 뒤에 있는 원소들을 모두 한칸씩 뒤로 이동시키는 과정이 선행되어야 한다.마찬가지로 원소를 삭제할 때도 삭제한 후 뒤에 있는 원소들을 한칸씩 앞으로 이동시켜야 한다. 연결리스트(linked list)연결리스트의 아이디어는 구조체가 값과 다음 원소의 위치 정보를 저장하고 있는 것이다.(많은 사람들이 손을 잡고 일렬로 서있는 것을 생각해 볼 수 있다.)노드라는 구조체를 주로 이용하는데, 노드는 자신의 값(value)와 다음 노드의 주소값을 원소로 갖는다. 어떤 원소에 접근하는 것 부터 배열과 차이를 보인다.만약 내가 index로 연결리스트의 어떤 원소에 접근하려면,첫 번째 노드에 접근하여 두 번째 노드의 주소를 찾고, 두 번재 노드에 접근하여 세 번째 노드의 주소를 찾고와같은 과정을 loop을 통해 반복해야 한다. 리스트 가운데에 원소를 삽입하거나, 중간에 위치한 원소를 삭제할 때 배열보다 연결리스트가 유리하다.그 원소의 위치를 찾을 때 까지는 위에서 언급한 방법으로 찾아야 하지만, 노드를 삭제할 때는 삭제하려는 노드의 이전 노드의 주소 값을 삭제하려는 노드의 다음 원소의 주소값으로 바꿔주면 된다.원소를 삽입할 때는 이전 원소가 갖고 있던 다음 원소의 주소값을 새 노드에게 알려주고,이전 노드에는 새 노드의 주소값을 저장하도록 해준다.말로 하면 어려워 보이지만 그림을 보면 이해하기 어렵지 않다. linked list의 종류가 몇가지 있다.노드가 이전 노드의 주소를 저장하도록 구현하면 이용할 때 조금 유리한 부분이 있는데,이렇게 구현된 linked list는 이중연결리스트라고 한다.그리고 끝나는 노드가 시작 노드의 주소값을 저장하고 있으면,원형연결리스트라고 한다.","link":"/2021/08/15/ds-al-1/"},{"title":"자료구조 &#x2F; 알고리즘 2 (스택, 큐, 덱 )","text":"이전 글에서 언급했다 싶이 스택, 큐, 덱은 모두 선형 구조인 리스트의 일부이다.다만 세 자료구조는 지원하는 연산이 다르다.스택과 큐는 서로 비슷하지만 반대된다고 생각할 수 있으며, 덱은 둘을 합쳐 놓았다고 볼 수 있다.어려운 내용은 아니니 쉽게 이해할 수 있을 것이다. 1. 스택 (stack)1.1 개념게임을 조금 해본 사람들은 스택을 쌓는다는 표현을 들어봤을 수 있다.스택을 배우고 나면 이 표현이 어느정도 알맞는 표현이였다고 생각하게 될 수도 있다. 스택은 들어오는 곳과 나가는 곳이 동일한 선형 구조이다.즉 뒤에 들어온 원소들이 나가줘야만 앞에 있는 원소들이 스택에서 나갈 수 있다.늦게 들어온 것이 먼저 나간다는 의미로 영어에서는 LIFO(LAST IN FIRST OUT) 라는 말을 사용한다.(스택을 설명하기 위해 자주 드는 예시는 프링글즈 통이다.) 스택은 아래서 부터 위로 쌓는 이미지로 생각해도 좋고,앞에서 부터 뒤로 쌓는 이미지로 생각해도 좋다.다만 중요한 것은 위에서 부터 혹은 뒤에서 부터, 즉 쌓인 원소부터 제거된다는 것이다. 스택이 활용되는 가장 대표적인 부분은함수들이 함수들을 실행하고, 프로그램이 프로그램을 실행할때스택에 쌓아가면서 실행하고 종료될 때는 위에 부터 종료되게 함으로 써내부의 함수 또는 프로그램이 외부의 함수 또는 프로그램 보다 먼저 종료되게 해준다. 1.2 지원하는 연산스택이 지원하는 연산은 크게 3가지 이다. push : 스택의 가장 뒤에 값 추가 // 스택의 가장 위에 값 추가 pop : 스택의 가장 마지막 값 제거 // 스택의 가장 위의 값 제거 top : 스택의 가장 마지막 값 반환 top은 사실 스택의 가장 위에 있는 원소를 말하는 것이지만, 연산의 이름으로 사용하는 경우도 많다. 위 연산 외에 중간에 위차하고 있는 값을 확인한다거나, 가장 아래의 원소를 제거 하는 등의다른 연산을 지원한다면 그것은 엄밀하게는 스택의 구조가 아니라고 할 수 있다.그러나 뭐 넓은 의미에서 위로 쌓이고 위에서부터 빠지고 하는 구조 자체를 말할때도 자주 사용한다. 2. 큐 (queue)2.1 개념큐는 스택과 달리 먼저 들어온 것이 먼저 나가는 구조이다.대표적으로 그냥 놀이공원 같은 곳에서 줄을 섰을 때를 생각하면 되는데,오래기다린 순서대로, 즉 앞에서 부터 처리되는 자료구조이다. 큐는 FIFO(FIRST IN FIRST OUT) 구조라고 불리기도 한다.큐는 위로 쌓는 이미지보다는 뒤로 원소들이 누적되고, 앞에서 부터 제거되는 이미지를 떠올리면 좋다. 운영체제가 프로세스들을 스케일링할 때 큐를 이용한다.(물론 그냥 큐는 아니고 큐의 응용이다.) 2.2 지원하는 연산 push : 큐의 가장 뒤에 값 추가 pop : 큐의 처음 값 제거 (이때 그 값을 return 해주기도 한다. back : 큐의 가장 마지막 값 반환 fromt : 큐의 가장 처음 값 반환 back의 경우 큐에서 무조건 지원해야 하는 내용은 아니지만c++의 queue 라이브러리에서 제공하기 때문에 적어두었다.스택과 비슷한 이름의 연산을 사용하지만, 아래서 부터 빠진다고 하는 경우는 거의 없기 때문에,마지막에 값을 추가하고, 앞에서부터 값이 제거된다고 생각하면 된다. 3. 덱 (deque)3.1 개념deque은 double ended queue, 즉 ‘양쪽이 끝인 큐’라는 말이다.따라서 양쪽에서 끝에서 값을 추가하고 제거하는 연산이 가능하다. 3.2 지원하는 연산 push_back : 덱의 가장 뒤에 값 추가 push_front : 덱의 가장 처음에 값 추가 pop_back : 덱의 마지막 값 제거 pop_front : 덱의 처음 값 제거 back : 덱의 마지막 값 반환 front : 덱의 처음 값 반환 at : index로 덱의 원소에 접근 at의 경우 덱에서 무조건 지원해야 하는 내용은 아니지만c++의 deque 라이브러리에서 지원하고 있기 때문에 적어두었다. 그렇다면 스택이나 큐보다 무조건 덱을 사용하는 것이 좋은 것 아닌가? 라고 생각 할 수 있다.하지만 필요없는 연산을 굳이 구현할 필요가 없을 수도 있고, 연산을 일부로 제한 해 둘 필요가 있을 수도 있다. 마무리스택과 큐 그리고 덱은 알고리즘 문제풀이를 위한 자료구조이기도 하지만컴퓨터공학의 전반적인 분야에서 설명을 할때 매우 자주 사용되는 내용이다. 따라서 당장의 필요가 없다하더라도, 그리고 구현을 직접 해보지 않더라도내용만 미리알아두는 정도로도 충분히 의미있다.","link":"/2021/08/18/ds-al-2/"},{"title":"cplus_typecasting","text":"어제 알고리즘을 풀다가 실수할만한 부분을 발견해서 짧게 정리한다.int형과 double형을 혼용해서 쓰면서 발생한 문제인데, 예시를 통해 설명해보겠다.어렵지 않고 매우 간단한 내용이다. 예시123456int main(void){ int a = 10 - (3 / 2); printf(&quot;%d&quot;, a);} 위 코드가 실행 되었을 때 출력되는 값은 9 이다.3 / 2 = 1.5 에서 0.5를 버리기 대문에 10 - 1 = 9 로 계산이 된다. 123456int main(void){ int a = 10 - (3.0 / 2); printf(&quot;%d&quot;, a);} 그런데 위 코드가 실행 되었을 때 출력되는 값은 8 이다.3.0 / 2 = 1.5로 계산이 되고, 10 - 1.5 = 8.5 로 계산이 된 후 0.5를 버리기 때문이다. 123456int main(void){ int a = 10 - int(3.0 / 2); printf(&quot;%d&quot;, a);} 이 코드는 3.0 / 2 의 결과인 1.5를 int형으로 바꿔버린 것이다.이렇게 바꾸면 다시 첫번째 결과와 동일하게 9를 출력한다. 내가 마주한 상황타입 변환에 관련 된 내용이라 나도 어느정도 아는 내용이였지만,내가 마주한 상황에서 생각하지를 못했다. &lt;math.h&gt;에서 pow()함수를 이용해서 제곱을 계산하였는데, 이 때의 return 값이 double이였다.그래서 위와 비슷한 예시에서 원하는 값을 얻지 못했다. 결론int 형과 double 형의 계산에서는int 형이 더 큰 메모리 공간을 갖는 double형으로 변환되어 계산된다.만약 그 후 대입 연산자가 있다면 대입연산자에 의해서 double 형이 int 형으로 자동형변환 되어 소수점을 버린다. 원하는 값을 얻기위해서는 필요한 순간에 강제 타입변환을 하거나, 모든 변수를 double형으로 통일한후에 원하는 타입으로 변환할 수 있다.","link":"/2021/08/24/cplus-typecasting/"},{"title":"자료구조 &#x2F; 알고리즘 3 (그레프, 트리, 힙)","text":"이전까지 다뤘던 자료구조와는 다르게 트리느 비선형 구조이다.선형적으로 즉 일렬로 데이터들이 있는 것이 아니다.대신에 트리는 계층적 구조라고 말하는데 이것이 선형구조의 반대되는 개념은 아니다.트리의 구조는 그림을 보면서 이해하는 것이 빠르다. 1. 그래프1.1 개념고등학교 때 까지 수학에서 다뤄왔던 그래프와는 좀 다르다.그래프란 정점(Vertex)와 간선(Edge)로 이루어진 자료구조를 말한다. 2. 트리2.1 개념트리는 특수한 그래프이다.그래프가 생긴 모양이 나무와 같아서 트리라는 이름이 붙었다. 그래프는 정점(Node)와 간선(Edge)로 이루어 진다는 것이 특징인데,트리는 한 정점에서 다른 정점까지의 길이 하나 뿐이라는 것이 특징이다.(조금 생각해보면 사이클이 존재하지 않는다는 것과 동의어임을 알 수 잇다.) &lt;그림&gt; 트리는 일반적으로 위와 같은 그림으로 표현된다. 트리의 하나의 정점 즉 노드는 부모 노드와 자식 노드를 갖는다.부모노드는 하나여야만 하고, 자식노드는 몇개든 상관없고 없어도 된다.최상단의 부모가 없는 노드를 루트 노드라고 한다. 2.2 용어 노드 : 하나의 값을 갖는 정점. 하나의 부모노드와 여러개의 자식노드를 갖을 수 있다. 간선 : 노드와 노드를 잇는 선분. 간선이 방향을 갖는 경우도 있다. 루트 노드 : 최상단의 노드로 부모노드를 갖지 않는다. 부모노드 / 자식노드 : 두 노드의 관계에서 위에 있는 노드르 부모노드, 아래있는 노드를 자식노드라고 부른다. 조상노드 : 부모 노드를 따라가다 보면 나오는 노드들을 말한다. 2. 힙","link":"/2021/08/29/ds-al-3/"},{"title":"실내&#x2F;실외&#x2F;음식 구분 - 프로젝트","text":"들어가며작년에 수업에서 진행했던 프로젝트를 정리해볼것이다. 코드가 길지 않고 간단하지만 내용으로 보면 쉽지 않고한학기 동안 실습했던 내용을 담고 있어서 배웠던 내용을 정리하는 데에 매우 도움이 되었다. 그때 진행했던 프로젝트를 리뷰하면서 복습해볼 생각이다. 프로젝트의 목표음식, 식당의 내부, 식당의 외부 중 하나에 속하는 이미지가 주어졌을 때,어디에 속하는 이미지인지 판단할 수 있는 모델을 만든다. 모델의 정확도는 높을수록 좋다. 이용할 데이터음식사진 20000장, 식당 내부사진 15000장, 식당 외부사진 10000장을 제공받았다.(수업을 듣는 학생들이 몇백장정도씩 직접 분류하였다.) 이 이미지들을 이용하여 학습하고 모델을 생성한다. 전체 코드많은양의 코드가 아니란 것을 보여주기 위해 전체코드부터 제공한다. 짧게 전체적인 과정을 먼저 설명하자면 다음과 같다. 모델 만들기 (함수) 그래프 그리기 (함수) 이미지 읽어오기 학습 코드 확인 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import numpy as npimport osimport matplotlib.pyplot as pltfrom tensorflow.keras.models import Sequential, load_modelfrom tensorflow.keras.layers import Input, Dense, Conv2D, MaxPooling2D, Flatten, BatchNormalizationfrom keras.utils import np_utils, to_categorical,multi_gpu_modelfrom keras.datasets import mnistfrom keras.preprocessing.image import array_to_img, img_to_array, load_imgfrom sklearn.metrics import accuracy_scorefrom sklearn.model_selection import train_test_splitdef gen_sequential_model(): model = Sequential([ Input(shape=(300,300,3), name = 'input_layer'), BatchNormalization(), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer1'), MaxPooling2D(pool_size=(2,2)), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer2'), MaxPooling2D(pool_size=(2,2)), Conv2D(32, kernel_size=(3,3), activation='relu', name='conv_layer3'), MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer4'), #MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer5'), MaxPooling2D(pool_size=(2,2)), Conv2D(64, kernel_size=(3,3), activation='relu', name='conv_layer6'), MaxPooling2D(pool_size=(2,2)), Flatten(), Dense(3, activation='softmax', name='output_layer') ]) model.compile(optimizer='adam', loss='categorical_crossentropy',metrics=['accuracy']) #model = keras.utils.multi_gpu_model(model, gpus=4) model.summary() return modeldef plot_loss_curve(history): import matplotlib.pyplot as plt plt.figure(figsize=(15, 10)) plt.plot(history.history['loss'][1:]) plt.plot(history.history['val_loss'][1:]) #plt.plot(history.history['val_loss'][1:]) plt.title('model loss') plt.ylabel('loss') plt.xlabel('epoch') plt.legend(['train', 'test'], loc='upper right') plt.show() #이거 캡쳐하기 path = r&quot;C:\\Users\\이종민&quot;trainFileList = os.listdir(path)trainFileList = [x for x in trainFileList if 'jpg' in x]train_datagen = ImageDataGenerator()training_set = train_datagen.flow_from_directory(path+&quot;\\images_train&quot;, target_size = (300, 300), batch_size = 32, class_mode = 'categorical')test_datagen = ImageDataGenerator()test_set = test_datagen.flow_from_directory(path+&quot;\\images_test&quot;, target_size = (300, 300), batch_size = 32, class_mode = 'categorical')model = gen_sequential_model()history = model.fit(training_set,steps_per_epoch=30, epochs=50, validation_data=test_set)model.save('이종민-2017114152')plot_loss_curve(history)print(history.history)print(&quot;train loss=&quot;, history.history['loss'][-1])print(&quot;test loss=&quot;, history.history['val_loss'][-1])print(test_set.class_indices)print(training_set.class_indices)","link":"/2021/09/03/image-classification-project/"},{"title":"GCD(Greatest common divisor) 알고리즘","text":"사실 알고리즘이라기도 애매할 정도로 쉬운 내용이다.내용은 쉬운데 꾸준히 나오며, 안배우고 처음에 이 방법을 생각해내긴 쉽지 않다.정리하면서 그냥 외우려고 작성한다. 설명A와 B의 최대공약수를 구해보자. A = ac, B = bc 이며 c는 최대공약수라 가정해보자.A &gt; B 라고 한다면 A와 B의 관계식을 다음과 같이 작성해 볼 수 있다.ac = k * bc + X (이때 k는 상수이며 X는 나머지 이다.) 우변이 c로 나눠지므로 X로 c로 나눠떨어져야 한다.ac = k * bc + X-&gt; ac = k * bc + xc 와 같이 식을 작성할 수 있다. 그러면 여기서 b와 x는 c라는 약수를 공유한다.따라서 bc와 xc의 최대공약수를 구함으로써 ac와 bc의 최대공약수를 구할 수 있다는 것이 아이디어이다. 그런데 bc와 xc의 최대공약수가 ac와 bc의 최대공약수임을 보장할 수 있는가?b와 x가 약수를 갖을 수도 있는것 아닌가?b와 c가 또다른 약수 d를 갖는다고 해보자. 그럼 식은 다음과 같이 바뀔 수 있다.ac = k * b’cd + x’cd만약 이런식으로 작성된다면 우변은 cd로 묶일 수 있다.그렇다면 좌변도 마찬가지로 cd로 나눠질 수 있어야 한다.a’cd = k * b’cd + x’cd따라서 여기서의 최대공약수는 cd이므로 A와 B의 최대공약수는 c라는 가정에 모순된다. 위의 과정을 반복하면서 X가 0일때,즉 나머지가 없을때의 작은수가 최대공약수가 된다. 매우쉬운 내용인데 글로 쓰니까 길기만 길다. 코드123456789101112131415161718def gcd(A, B): if B &gt; A: A, B = B, A if B &lt; 1: return 0 while(True): X = A % B if X == 0: break A = B B = X return B","link":"/2021/10/21/gcd-algorithm/"},{"title":"While문 습관 바꾸기","text":"나는 while문을 작성할 때,while 옆에 조건을 바로 작성하지 않고 조건을 만족할 때 break하도록 주로 작성한다 이게 나쁘다고는 생각하지 않고 스스로 코드를 이해할 때도 편하긴한데,남의 코드를 참고하거나 남들이 내 코드를 볼 때는 불편할 수도 있겠다 싶어서 바꾸려고 한다. 내용기존의 나는 다음과 같이 작성했다. 12345678910while(True): # ... (1) if 조건문: break # ... (2) 바꾸려고 의도하는대로 바꾸면 다음과 같다. 12345while(!조건문): # ... (1) + (2) 기존에 작성하던 방식을 아래와 같이 바꾼는 것은 어렵지 않다.while 옆의 조건에 원래 작성하려던 조건의 부정문을 작성해주면 된다. 다만 다음과 같이 작성했을 때 생길 수 있는 문제가 있는데. 위의 방식에서는 (1)번 코드는 조건문 검사없이 무조건 한번은 실행되는 반면,아래의 방싟에서는 (1)번 코드가 실행되기 전에 조건문 검사를 실행한다. 그러면 do-while뭐 이런걸 실행하면 되는데 더 보기 어려울 것 같다.그냥 while 전에 (1)코드를 한 번 실행할 수 있도록 해주거나, 조건을 조금 바꿔주는 편이 좋을 것 같다. 예시12345678910x = 0while(True): x += 1 if x == 3: break print(&quot;hi&quot;) 위의 코드를 아래와 같이 바꾸면 문제가 생긴다. 123456x = 0while(x!=3): x += 1 print(&quot;hi&quot;) 문제가 생기지 않게 하려면 아래 방법처럼 바꿀 수 있다.(당연히 다른 방법도 많이 있다.) (1)번 코드를 미리 한번 실행하는 것으로 처리 1234567x = 0x += 1while(x!=3): x += 1 print(&quot;hi&quot;) 조건을 조금 바꿔줌으로써 처리 123456x = 0while(x!=2): x += 1 print(&quot;hi&quot;) 정리쉬운 내용이지만 나를 위해서 정리해봤다 ㅎㅎ","link":"/2021/10/22/fix-whileloop/"},{"title":"Iterable_object","text":"파이썬은 반복문을 iterable한 객체를 통해 진행한다.어떻게 작동하는지 공부하고 작성한 글이다. iterable 객체(ierable과 iterator)쉽게 이해하고 싶은 사람은 iterable한 타입이란 iterator라는 어떤 객체를 통해 다음 값에 접근 할 수 있도록 설계되어 진 것이라 생각하면 된다. 대표적으로 list, tuple, dictionary, set, range, string이 있고 그리고 iterable한 객체들은 for문에서 사용될 수 있다는 것까지 알아두면 좋다. iterator = 반복자, iterable = 반복가능한 타입이라고 생각을하면 쉽다. 예시를 작성해보겠다. list 와 list에 대한 iterator는 다음과 같이 생성할 수 있다. a = [1, 2, 3, 4, 5] a_iterator = iter(a) next(a_iterator) a 는 list고 이는 iterable한 타입이다. 그리고 다음줄에 선언한 a_iterator가 리스트 a에 대한 iterator이다. 리스트 a에 대한 iterator가 생성가능하므로 a는 iterable하다고도 할 수 있다. a_iterator는 next라는 함수를 통해 리스트의 다음 값에 접근 할 수 있다. 이렇듯 iter()을 이용하여 iterator 객체를 생성가능한 것들을 iterable 하며 iterable 한 객체는 내부적으로 매직메소드 __iter__를 갖고 있다. 디자인 패턴에서 iterator 패턴이 있다. 정의는 '컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공해 주는 패턴' 이다. 실제로 대부분은 for문에서 iterable한 객체가 쓰일 수 있다는 것은 알지만 이게 어떻게 가능한 것인지는 모른다. 그것 자체로 컬렉션의 구현 방법을 노출시키지 않았다고 할 수 있다. 또한 위의 예제에서도 iterator 객체를 통해 원하는 값에 접근은 가능한 반면 실제로 list라는 컬렉션이 어떻게 구현되어 있는지에 대한 정보를 알 필요가 없다. 참고) https://suwoni-codelab.com/python%20%EA%B8%B0%EB%B3%B8/2018/03/06/Python-Basic-Iterable-iterator/ for in문에서 iterable 객체파이썬에서는 주로 for in 문을 사용하여 반복문을 나타낸다. for in 문에서 반복의 조건으로 iterable 객체들이 사용될 수 있다. iterable 객체란 반복이 가능한 객체로 list, tuple, dictionary, set, range, string, byte들이 이에 해당한다. 사용방법은 다음과 같다. for item in iterable: 반복할 부분.... ex) for i in range(20): print(i) 다른 언어에서는 주로 몇번째 반복인지의 count를 이용해서 list[count]처럼 접근해야 했던 것과는 달리, 바로 그 시행에서의 item을 이용할 수 있다. iterable한 객체를 list로list() 함수를 이용하여 iterable한 타입의 객체를 list로 바꿀 수 있다. a = list(range(10)) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] b = list(combinations([1, 2, 3, 4], 2)) [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]","link":"/2021/12/06/Iterable-object/"},{"title":"compiled vs interpreted","text":"매번 강조되는 내용이고 적당히 알고있었다.공부하다가 궁금했고 글로 정리했다. Compiled Languages vs Interpreted Languages주로 컴파일 언어, 인터프리터 언어라고 부른다. 근데 compile에 대응되는 단어는 interpret, interpreter 에 대응되는 단어는 compiler이다. 영어로는 Compiled Languages and Interpreted Languages라 사용 되는거 보니 컴파일 언어, 인터프리터 언어로의 번역은 조금 잘 못된 것 같긴하다. 컴파일러, 인터프리터는 일단 소프트웨어(프로그램)이라는 것을 확실히 하고 시작하자. (그러면서 위의 단어가 잘못되었음을 알았다.) 컴파일러는 내가 프로그래밍 언어로 작성한 문서를 한번에 기계어로 바꿔 실행 파일을 생성해주는 소프트웨어이다. 그리고 인터프리터는 내가 프로그래밍 언어로 작성한 문서를 번역하며 실행까지 해주는 소프트웨어이다. 즉 컴파일러가 생성한 실행파일은 컴퓨터가 직접 실행이 가능하며, 인터프리터는 실행파일을 만들지 않고 코드를 직접 인터프리터가 실행한다. 밑의 내용을 보면 조금 확실해진다. 여러 것들을 찾아보고 공부해본 결과 Compiled Languages와 Interpreted Languages를 구분하는 기준은 &quot;코드 전체를 한번에 기계어로 번역 하느냐&quot;이고, 이 이유 때문에 여러 차이점이 존제한다. Compiled Languages는 코드 전체를 한번에 기계어로 번역한다. 기계어로 번역한 그것이 실행 파일이 되는 것이다. 물론 코드 전체를 번역해야 하는데 시간이 좀 소요되지만, 실행 속도는 컴퓨터가 기계어를 직접읽기에 매우 빠르다. 또 한번에 전체 코드를 번역하다보니, 최적화의 부분에서도 장점을 갖는다. 그런데 코드를 수정하는데 있어서는 번거롭다. 전체를 실행하면서 오류를 찾아 내야 하고, 오류를 찾아 냈다고 하더라도 다시 전체 코드를 컴파일 해야한다. 또한 이 부분은 내 생각이긴 한데, C언어에서 타입에 대한 검사나 메모리 할당을 미리 하는 이유는 컴파일 하기 전에는 어떤 변수가 어떤 값을 갖을지 어차피 알고 있다. 또한 메모리도 어느 정도 필요한지를 미리 알 수가 있다. 그래서 그런 것에 대한 검사를 엄격하게 하면서, 컴파일시 최적화의 이점을 더욱 살리려고 한 것 같다. 반면 Interpreted Languages는 코드 전체를 한번에 기계어로 번역하지 않는다. 그렇기 때문에 전체 코드를 기계어로 번역한 실행 파일이 생성 되지 않는다. 실행시키는 부분의 번역만을 진행한다. 실행 시간에 번역시간도 포함되게 됨으로 실행 시간이 비교적 오래걸릴 수 밖에 없다. 또한 코드의 최적화도 실행시키는 부분내에서만 일어날 수 있다. 현재까지 진행한 부분을 실행해보면서 오류를 수정하고 수정하여 다시 그 부분을 실행해보면 되기 때문에 코드 수정에서의 유리함이 있다. 위의 내 생각에 추가해보자면, 인터프리터 언어는 앞으로 어떤 코드가 작성될 지 알 수 없다. 그렇기 때문에 타입을 선언하여 미리 크기를 정해두기 힘들다. 순간적으로 입력되는 값에 따라서 메모리의 크기를 알맞게 할당할 수도 있고, 크기가 바뀌면 주소를 바꿔야 할 수도 있다. 그렇기에 타입 검사 포기하고 조금 더 융통성 있는 코드를 가능하도록 했을 것이다. Is Java Complie Language?Java가 어떻게 작동하는지는 조금 더 길게 다른글에 정리해 두었으니 읽어보면 좋을 듯하다. 일단 자바는 javac 컴파일러를 이용하여 전체 코드를 한번에 바이트 코드로 바꾸기 때문에 Compiled Language가 맞다. 그 다음에 JVM에서 .class 파일을 기계어로 바꾸며 실행할 때 interpreter를 이용한다. 따라서 interpreter Language도 맞다. 그래서 결국 두 방식을 같이 사용한다고 하는 것이 맞는 것 같다. 뭐 여기서 interpreter를 JIT(Just in time)compiler로 설명하는 내용도 많은데 따로 정리할 시간이 있으면 따로 정리해보겠다.","link":"/2021/12/06/compiled-vs-interpreted/"},{"title":"자바에 대해서","text":"처음 프로그래밍을 배울 때 자바로 시작하는 경우가 많다.자바를 설치하고, 환경 변수를 설정하고, 이클립스를 깔고, 따라 치고, 실행 하고.. 물론 처음에 자바가 무엇인지부터 시작한다면 이해 할 수 없을 것이다.그러나 자바를 계속 사용하기 위해서는 언어외에도 계속 마주하는 용어들이나 작동하는 방식들에대한 정리가 필요하다고 느꼈다. 플렛폼으로써의 자바자바(Java)는 자바로 기술된 프로그램 개발 및 실행을 할 수 있는 소프트웨어 모임의 총칭이다. 자바 프로그램은 운영체제나 하드웨어에 의존하지 않는 바이트 코드(중간 언어)인 추상적인 코드 로 구현된다. 따라서, 자바 프로그램을 실행하기 위해서는 자바 가상 머신(JVM)과 개발에 필요한 표준 라이브러리 세트와 컴파일러의 환경만 맞추면 자바 프로그램은 모든 환경에서 동일하게 동작한다. 이러한 실행환경과 개발환경을 제공하는 것이 자바 플랫폼이다. 자바 플랫폼은 자바 언어(Java Language), 자바 애플리케이션(Java Application), 자바 애플릿(Java Applet), JRE(Java Runtime Environment), 자바 가상 머신(Java Virtual Machine), 모바일용 자바(Java ME), 자바 웹 스타트(Java Web Start) 등과 함께 단순히 「자바」(Java)라 불리는 경우가 많다. 출처: https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%94%8C%EB%9E%AB%ED%8F%BC) 내가 정리하고자 했던 내용을 직접 작성하는 것 보다 훨씬 뛰어나게 잘 요약된 글이 있어서 그대로 가져왔다. 자바의 실행방식 : 자바 플랫폼Java의 실행방식은 조금 특이하다. 컴파일 언어와 인터프리터 언어의 방식을 모두 사용한다고 할 수 있다. 먼저 개발자가 작성한 코드는 .java 파일에 저장이 된다. 작성된 코드는 실행을 위해 컴파일이 되어야 하고 그 결과가 .class 파일이다. 이 파일은 JVM(Java Virtual Machine)이라는 가상환경에서 실행된다. 이 때 실행되는 방식이 인터프리터 방식이다. JVM은 .class파일의 바이트 코드를 한줄 씩 해석하며 실행한다. WORA(Write Once, Read Anywhere) 플랫폼에 종속되지 않고 사용하기 위해서 이 방식을 채택하였다는 것이 중요하다. 컴파일이란 개발자가 작성한 코드를 실행 가능한 파일로 바꾸는 과정이라 생각하면 된다. 그런데 CPU마다 명령어의 체계가 다르고 운영체제에 따라 API도 다르다. 따라서 일반적인 컴파일 언어에서 컴파일 된 파일은 다른 환경에서 작동하지 않을 가능성이 높다. Java의 경우 그것을 JVM을 통해 해결한다. 컴파일 된 바이트 코드는 JVM 위에서 실행되기에 환경에 신경쓰지 않고 실행될 수 있다. 물론 컴파일 된 자파 파일 .class 파일을 해석할 수 있는 자바 플렛폼을 설치되어있어야만 하고, 특정 운영체제만 갖고있는 기능은 이용하지 못할 수도 있다는 단점이 있다. JDK, JRE다운로드를 하려다 보면 마주하게 되는 단어들이다. JRE은 Java Runtime Environment의 약자이다. JRE는 개발을 하지 않지만 자바 파일을 실행해야 하는 사람들이 다운 받으면 되는 것 이다. 실행할 수 있도록 하는 JVM을 포함하여, 라이브러리 등이 포함된다. .class파일을 JVM에서 실행하기 위한 JIT(just in time) compiler, 메모리의 관리를 도와주는 garbage collector등도 포함되어 있다. JDK는 Java Development Kit의 약자이며, 다시 말해 자바 개발을 하기 위해 필요한 묶음이다. 코드를 작성하고 실행해볼 때는 라이브러리들도 필요하고, 컴파일의 과정도 거쳐야하며, 컴파일의 결과를 JVM위에서 실행도 해봐야 한다. 이런 모든 것들을 묶어서 배포하는 것이 JDK이다. 따라서 JDK를 다운로드 받으면 JRE도 포함되어 있다. 가장 중요한 차이는 컴파일을 하기 위한 javac의 포함 여부이며 다른 javadoc(Java documentation generator)이나 jdb(Java Debugger)같은 툴또한 JDK에만 제공된다. JVM 추가https://stackoverflow.com/questions/7674839/is-the-jvm-a-compiler-or-an-interpreter 매우 좋은 글이 있어서 가져왔다. 직접 읽는 것이 더욱 좋다. 질문 : JRE는 컴파일러냐 인터프리터냐 둘다 아니라면 무엇이냐? 답 : JVM is Java Virtual Machine -- Runs/ Interprets/ translates Bytecode into Native Machine Code JVM is a virtual platform that resides on your RAM Its component, Class loader loads the .class file into the RAM The Byte code Verifier component in JVM checks if there are any access restriction violations in your code. (This is one of the principle reasons why java is secure) Next, the Execution Engine component converts the Bytecode into executable machine code JVM은 램위에 존재하는 가상 플랫폼이다. 그것의 구성요소인 Class loader는 .class파일을 램 위에 올린다. 다른 구성요소인 Byte code Verifier는 코드의 접근 제한이나 위험을 검사한다. (이것이 자바가 안전한 이유 중 하나이다.) 그리고 실행 엔진이 바이트 코드를 실행가능한 기계코드로 바꾼다. https://www.guru99.com/java-virtual-machine-jvm.html https://www.youtube.com/watch?v=G1ubVOl9IBw&amp;t=2s 이것 또한 참고할만하다. 버전java version 을 보면 8, 9, 10, 11 이렇게 볼 수 도 있고 1.7.2, 1.8.0과 같이 적혀있는 것도 볼 수 있다. java 9 이전의 버전에서는 버전을 작성하는 방식이 달랐기 때문에, 1.8.0과 같이 작성되었다. 9 이후의 버전에서는 java 9, java 11과 같이 작성한다. 이전 버전에서 컴파일 된 파일은 이후 버전의 jre에서 실행이 가능하다. 그러나 반대는 불가능하다. 또한 이후 버전의 java에서 이전 버전으로 컴파일을 하는 것도 불가능하다. SE vs EEjdk를 다운로드 받을 때 선택하게 된다. SE는 Standard Edition, EE는 Enterprise Edition의 약자이다. 쉽게 말해 일반적으로 사용하기 위해서는 SE, 조금 더 많은 기능을 지원해주는 것이 EE이다. 결합력을 낮추기 위한 DI, DB Transaction 처리, 로그 처리 등이 주요한 기능이였다. EE는 유료인데다가 spring framework가 그 기능들을 잘 지원해 주기에 요즘은 java se에 spring framework등을 얹어서 사용하는 경우도 많다. 참고https://www.oracle.com/java/technologies/javase/jdk8-naming.htmlhttps://dzone.com/articles/a-guide-to-java-versions-and-features","link":"/2021/12/06/abuot-java/"},{"title":"데이터베이스 인덱스","text":"학교수업에서 배웠던 내용 중내가 흥미로웠던 부분을 짧게 정리했다. 데이터베이스 모델링현실 세계의 개체들은 수많은 특성을 갖는다. 예를 들어 한 사람은 이름, 키, 성별, 직업, 수입, 사는 지역, 주민 번호 등 여러 가지 속성들을 가지고 있다. 데이터베이스가 이 모든 정보를 갖고 있을 수는 없다는 것뿐만 아니라 다 저장할 필요도 없다는 사실을 모두 알고 있다. 필요한 정보만 데이터베이스에 저장하면 되고, 그것을 어떻게 저장하고 있을지가 모델링이라 할 수 있다. 따라서 데이터베이스를 모델링은 쉽게 시스템에 필요한 개체는 무엇인지, 개체들이 어느 속성을 가져야 하는지를 정하는 과정이다. 이 과정애서 굉장히 많은 추상화가 일어났다고 할 수 있다. (학생정보시스템에서 필요한 정보는 사람에 대한 모든 정보가 아니다. 단순히 학번, 이름, 학과 등 몇가지 요소들 만으로 표현될 수 있다.) 데이터베이스 인덱스데이터베이스가 학생에 대한 정보를 가지고 있다고해보자 그리고 간단하게 학생은 이름, 학번, 학과만을 갖는다고 하자. 데이터베이스에서 sql을 이용하여 어떤 학생을 찾을 때 얼마나 시간이 소요될까? 튜플들 간에 순서는 없다고 배우니 아마 서치 타임은 O(n)일 것이다. 그런데 저장을 할 때 순서대로 저장을 하도록 할 수 있다. 그리고 이를 이용하여 찾을 때의 서치타임을 줄일 수 있다. 위 테이블에서 주키인 학번 순으로 정렬되어 있다고 하면 내가 1234가 학번인 학생을 찾을 때의 서치 타임은 O(log n)이 된다. (binary search를 이용) 이것은 매우 큰 차이이다. (후에 서술) 그런데 학번 순으로 정렬이 되어있으면 이름으로 검색할 때는 서치 타임이 O(n)아닌가? 하나의 기준으로 정렬이 되어 있으면, 그 기준이 아닌 모든 것에 대해서는 다 O(n)으로 서치하게 된다. 그래서 존재하는 것이 인덱스이다. 위 예시에서 이름과 학번만을 묶어서 또 다른 구조체을 만들고 이름 순으로 정렬해 놓는 것이다. 그렇게 하면 이름으로 검색할 때 그 구조체에서 학번을 O(log n)의 서치타임으로 찾을 수 있다. 그리고 학번을 이용해서 원래의 테이블에서 검색할 때도 O(log n)만큼이 소요됨으로 O(log n)의 상수 배 시간만큼 걸린다. 데이터가 100만개라고 해보자. 인덱스를 이용하지 않고 이름으로 어떤 데이터를 찾을 때는 평균 50만번의 비교연산이 필요하다. 그러나 인덱스를 이용하면 100만 = (2^10)^2 = 2^20 이므로 20번의 연산 2번, 즉 40번의 연산 만으로 찾을 수 있다. 데이터가 많을 수록 인덱스의 사용이 더 중요해지는 이유이다.","link":"/2021/12/06/database/"},{"title":"파이썬을 파이썬답게","text":"시작부스트캠프 코딩테스트를 앞두고, 코딩테스트 공부를 했다. 내용자체가 어려울 것 같지는 않고, 구현이 까다로울 것 같아서 파이썬에 조금 더 익숙해지고자 했다. [파이썬을 파이썬답게](https://programmers.co.kr/learn/courses/4008) 라는 좋은 온라인코스가 있어서 빠르게 진행해봤다. 파이썬에서 이용할 수 있는 팁들을 많이 얻을 수 있다. 내용어렵진 않고 몰라서 못했던 내용임으로 단편적인 내용들을 쩗게나열하는 형식으로 작성하겠다. 1. int()함수는 base가 설정가능하다. print(int('10', base = 5)) = 5 print(int('f', base = 16)) 2. 알파벳은 lower(), upper()함수로 대문자 소문자 변환이 가능하다. 3. map()함수의 사용법 map(function, iterable)과 같이 사용하며, iterable한 객체를 돌면서 funtion을 실행한다. return type은 map object 이다. 리스트로 사용하고 싶다면 list()를 통해서 리스트로 변경해줄 수 있다. 4. zip()함수의 사용법 zip(iterable A, iterable B)와 같이 사용하며, iterable한 객체를 돌면서 둘을 합친 반복자를 반환한다. return type은 zip object 이다. zip object또한 iterable한 객체이며, list()를 통해서 리스트로 변경해줄 수도 있다. zip 함수에 서로 길이가 다른 리스트가 인자로 들어오는 경우에는 길이가 짧은 쪽 까지만 이터레이션이 이루어진다. 5. *로 unpacking이 가능하다. 6. for-else문이 가능하다. for _ in X: if 조건: 실행1 break else: 실행2 break가 일어나지 않으면 else가 실행된다! 7. iterable object to string object s = ''.join(iterable) 8. flatten 2D list to 1D list 1) answer = sum(my_list, []) -&gt; list + list = list 2) list(itertools.chain(*my_list)) -&gt; unpacking을 이해해야한다! -&gt; itertools.chain(iterable1, iterable2, iterable3) 간단히 말하면 리스트(lists/tuples/iterables) 를 연결하는 것이다. 3) [element for array in my_list for element in array] -&gt; list comprehension 4) np.array(my_list).flatten().tolist() -&gt; using numpy 9. iterable 객체의 곱집합 list(itertools.product(iterable1, iterable2, iterable3)) 10. 파이썬의 list comprehension을 사용하면 한 줄 안에 for 문과 if 문을 한 번에 처리할 수 있다. l = [x*x for x in range(10) if x%2 == 0] -&gt;[0, 4, 16, 36, 64] 11. 이분탐색이 구현되어 있다. bisect를 import 하고 bisect()와 bisect_left()를 사용할 수 있다. bisect(list,val)는 list에서 val이 추가될 때의 index를 return 한다. bisect_left는 index하나 감소 (정렬된 상태에서 사용하자) 12. from collection import deque deque은 매우 장점이 많은 자료구조이다. queue나 stack의 자료구조의 이해는 필요하지만 두자료구조를 구현할 때 deque을 써서 나쁠게 없다. (특히나 코테에선 더욱 그러하다.) 13. gcd 또한 구현되어있다. gcd = math.gcd(A, B) 정리파이썬은 확실히 사용하기 편하고 보기 편한게 장점인 것 같다. 새롭게 알게되는 내용이 있다면 추가해야겠다. 혹시 누가보실진 모르겠지만, 내용을 매우 얕게 정리해두었으니 몰랐던 내용이 있으시다면 조금 더 찾아보시는게 좋을것 같아요!","link":"/2021/12/17/study-python-skills/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"리스트","slug":"리스트","link":"/tags/%EB%A6%AC%EC%8A%A4%ED%8A%B8/"},{"name":"스택","slug":"스택","link":"/tags/%EC%8A%A4%ED%83%9D/"},{"name":"큐 - 덱","slug":"큐-덱","link":"/tags/%ED%81%90-%EB%8D%B1/"},{"name":"트리","slug":"트리","link":"/tags/%ED%8A%B8%EB%A6%AC/"},{"name":"프로젝트","slug":"프로젝트","link":"/tags/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"머신러닝","slug":"머신러닝","link":"/tags/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/"},{"name":"이미지 분류","slug":"이미지-분류","link":"/tags/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%84%EB%A5%98/"},{"name":"gcd","slug":"gcd","link":"/tags/gcd/"},{"name":"짧","slug":"짧","link":"/tags/%EC%A7%A7/"},{"name":"자료형","slug":"자료형","link":"/tags/%EC%9E%90%EB%A3%8C%ED%98%95/"},{"name":"타입변환","slug":"타입변환","link":"/tags/%ED%83%80%EC%9E%85%EB%B3%80%ED%99%98/"},{"name":"while문","slug":"while문","link":"/tags/while%EB%AC%B8/"},{"name":"iterable","slug":"iterable","link":"/tags/iterable/"},{"name":"iterator","slug":"iterator","link":"/tags/iterator/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"compiled laguage","slug":"compiled-laguage","link":"/tags/compiled-laguage/"},{"name":"interpreted laguage","slug":"interpreted-laguage","link":"/tags/interpreted-laguage/"},{"name":"컴퓨터언어","slug":"컴퓨터언어","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%96%B8%EC%96%B4/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"파이썬","slug":"파이썬","link":"/tags/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}],"categories":[{"name":"blog","slug":"blog","link":"/categories/blog/"},{"name":"자료구조&#x2F;알고리즘","slug":"자료구조-알고리즘","link":"/categories/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"c++","slug":"c","link":"/categories/c/"},{"name":"프로젝트","slug":"프로젝트","link":"/categories/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8/"},{"name":"알고리즘","slug":"알고리즘","link":"/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"짧","slug":"짧","link":"/categories/%EC%A7%A7/"},{"name":"study","slug":"study","link":"/categories/study/"},{"name":"파이썬","slug":"파이썬","link":"/categories/%ED%8C%8C%EC%9D%B4%EC%8D%AC/"}]}